---
title: jvm-gc
date: 2020-04-13 16:15:39
tags:
- JVM
categories:
- JVM
- GC
---

## 概述  

Java 的垃圾收集器作为这门语言的特点之一，是一个很重要的知识点。尽管大多数编程情况下我们不用关心 GC 层面的情况，但是理解 Java 中的对象是如何被自动化回收有利于我们深入的理解 JVM 的运行机制。  

了解 GC 和内存分配可以让我们在需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们能够游刃有余的监控和调节 GC。 


## 对象“判活”算法

Java 中的对象实例存储在“堆内存”中，而垃圾收集器就是回收这一个区域中的内存。垃圾收集器在对堆内存进行回收之前，首先要做的就是确定这些对象还有哪些还“存活着”，哪些对象已经“死去”。  

### 引用计数算法  

引用计数算法是最简单高效的垃圾回收算法。它的工作模型是：  

给每一个对象添加一个引用计数器，每当有一个地方要引用它时，计数器就加一；当引用失效时，计数器的值就减一；任何时刻计数器为零的对象实例都是不能在被使用（需要回收这部分内存的）的。  

但是这个算法有一个很大的局限性：对对象之间的循环引用的垃圾回收无能为力。  

举例说：当一个对象 A 中存放着一个对象 B 的引用，而对象 B 又存放这对象 A 的引用，那么当消除这两个对象的外部引用的时候，理应被回收的两个对象的内存如果在引用计数算法的垃圾回收器下是不能被回收的。而 Java 虚拟机也没用使用这种算法来判断对象是否存活。  

### 根搜索算法  

Java 主要是使用根搜索算法（GC Roots Tracing）来判断对象是否存活。  

这个算法的工作模型是：通过一系列名为 “GC Roots" 对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径被称为引用链，当一个对象到 GC Roots 没有任何引用链项链（用图论解释为从 GC Roots 到这个对象不可达）时，则证明这个对象是不可用的。  

在 Java 中，可作为 GC Roots 的对象包括以下几种：  

- 虚拟机栈中的引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中的引用的对象  

## 引用 

引用是对象是否被垃圾回收器收集的关键。Java 中对引用的概念进行了分类：  

- 强引用：强引用就是指代码中普遍存在的，像 “Object obj = new Object()” 这类的引用。这种类型的引用只要还存在，垃圾回收器永远不会回收被引用的对象所占用的内存。  
- 软引用：软引用用来描述一些还有用，但是非必须的对象。对于软引用的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围并进行二次回收。
- 弱引用：弱引用也是用来描述非必须对象的，但是他的强度比软引用跟弱。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。

上述4中引用按强度分逐渐降低。   

## 垃圾收集算法  

### 标记-清除算法

这种算法是最基础的收集算法。这种算法分为标记和清楚两个阶段：首先标记出所有需要回收的对象，在标记完成后统一进行回收操作。这种算法主要有两个缺点：  

1. 效率低，标记和清除的操作效率都很低。
2. 空间利用率低，标记对象的那部分内存被清除后，会产生大量不连续的内存碎片。会导致之后在分配较大对象的时候无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。

### 复制算法  

复制算法是为了解决效率问题而存在的。复制算法通过将可用内存按容量分为大小相同的两个区域，每次为对象分配内存的时候，只使用其中一部分，当进行收集操作的时候，就将这一部分还活着的对象复制到另一块内存中，然后对已使用的那部分内存进行回收。这样使得每次都是对其中一快进行内存回收，内存分配也不会出现不连续的情况。  

这个算法的缺点就是空间利用率太低了。这样管理内存会浪费掉一半的内存空间，代价太高。

### 标记-整理算法  

标记整理算法的标记过程与标记清除算法一致，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都想一端移动，然后直接清理掉端边界以外的内存。

### 分代收集算法  

Java 堆根据对象的存活周期的不同将其分为：新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。  

几乎所有的对象都是在新生代中诞生的。新生代中的对象具有“朝生夕死”的特性，也就是说这块内存区域中的对象生命周期很短。新生代中的内存采用复制算法，因为这部分内存中的对象在每次垃圾收集的时候都会有大部分对象死去，只有少部分存活，采用复制算法只用付出少量存活对象的复制成本就可以完成收集。  

新生代默认分为 80% Eden 区，10% From Servivor 区和 10% To Servivor区，每次垃圾收集将 Eden 和一个 Servivor 区中存活的对象复制到另一个 Servivor 区，然后将 Eden 和 Servivor 区中的内存清理掉。  

在每次新生代的垃圾收集过程中，存活下来的对象年龄都会加一，当达到某个年龄限制时（一般是15），将这个对象放入老年代。或者在每一次收集中，当存活下来的对象放不下 10% 的 Servivor 区的时候，这些对象直接进入老年代。  

老年代中对象经历了时间的考验，一般存活周期很长，这部分区域的垃圾收集操作没有新生代频繁，这部分的垃圾收集算法采用“标记清理”或“标记整理”算法来进行内存回收。