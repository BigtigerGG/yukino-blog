<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/yukino-blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/yukino-blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/yukino-blog/images/favicon.png">
  <link rel="mask-icon" href="/yukino-blog/images/favicon.png" color="#222">

<link rel="stylesheet" href="/yukino-blog/css/main.css">


<link rel="stylesheet" href="/yukino-blog/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://bigtigergg.github.io/yukino-blog').hostname,
    root: '/yukino-blog/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="a blogging site to log my study and life">
<meta property="og:type" content="website">
<meta property="og:title" content="Yukino&#39;s Blog">
<meta property="og:url" content="https://bigtigergg.github.io/yukino-blog/index.html">
<meta property="og:site_name" content="Yukino&#39;s Blog">
<meta property="og:description" content="a blogging site to log my study and life">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yukino Li">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bigtigergg.github.io/yukino-blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yukino's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/yukino-blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yukino's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">study and life</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/yukino-blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/yukino-blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/yukino-blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/yukino-blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/yukino-blog/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/yukino-blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vuex/vuex-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vuex/vuex-base/" class="post-title-link" itemprop="url">Vuex 基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-27 16:51:29" itemprop="dateCreated datePublished" datetime="2020-01-27T16:51:29+08:00">2020-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vuex/" itemprop="url" rel="index">
                    <span itemprop="name">Vuex</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vuex-基础"><a href="#Vuex-基础" class="headerlink" title="Vuex 基础"></a><strong>Vuex 基础</strong></h1><p>这篇文章记录 Vue生态的状态管理模式—— Vuex，同时也记录了自我见解。  </p>
<h2 id="什么是状态管理模式"><a href="#什么是状态管理模式" class="headerlink" title="什么是状态管理模式"></a><strong>什么是状态管理模式</strong></h2><p>通常，<strong>一个 Vue 组件的数据被称为这个组件的状态</strong>，它是驱动应用的数据源。Vue 的视图，也就是模板以声明式的方式将这些状态映射到 DOM 中。同时，Vue 的响应式机制能够根据这些状态的不同将变换的数据在视图中也能得到变化。  </p>
<p>通常，在简单的 Vue 组件中，数据的流动方向是“单向的“。如下图所示：  </p>
<p><img src="/yukino-blog/images/flow.png" alt="flow">  </p>
<p>单项数据流让 Vue 组件的可预测性，可维护性得到了保证。  </p>
<p>但是当组件之间需要共享一些状态的时候，单项数据流很容易被破坏：  </p>
<ul>
<li>多个视图依赖同一个状态（即多个组件需要共享同一份数据）</li>
<li>来自不同视图的行为需要变更同一个状态（即多个组件需要只改变一份数据对象）  </li>
</ul>
<p>使用 props 传参可能在一定程度上能解决第一个问题，但是当组件的数量增多，这些嵌套的组件会让传参变得十分繁琐，降低了代码的复用性。并且传参对于兄弟组件之间的数据传递无能为力。  </p>
<p>对于问题二，如果使用父子组件之间直接引用，通常会导致不可维护的代码，因为它直接破坏了 Vue 的”单项数据流“理念。  </p>
<p>为了解决这个问题，Vue 将这些组件之间需要共享的状态抽离出来，并在此基础上继承了一些额外的功能和框架，形成了 Vue 的状态管理模式—— Vuex。  </p>
<h2 id="合理地使用-Vuex"><a href="#合理地使用-Vuex" class="headerlink" title="合理地使用 Vuex"></a><strong>合理地使用 Vuex</strong></h2><p>Vuex 始终是为了简化大型SPA（单页应用）的开发，如果在一些简单的应用中使用Vuex，它可能是多余且繁琐的。  </p>
<p>在简单的应用中，可以使用一个简单的 <code>store</code> 模式：  </p>
<pre><code>const store = {
    debug: true, // or false
    state:{
        sharedMessage: &apos;hello world&apos;
    },
    clearSharedMessageAction(){
        // doSomeDebugThing
        if(debug) window.console.log(&quot;...&quot;)
        // doOtherThings
        // ...
        this.state.sharedMessage = &apos;&apos;
    },
    setSharedMessageAction(newValue){
        // doSomeDebugThing
        if(debug) window.console.log(&quot;...&quot;)
        this.state.sharedMessage = newValue
    }
}

new Vue({
    data(){
        return {
            sharedState: store.state,
            privateState: {
                privateMessage: &quot;private message&quot;
            }
        }
    },
    methods:{
        clearSharedMessage: store.clearSharedMessageAction,
        setSharedMessage: value =&gt; store.setSharedMessageAction(value)
    },
    template: `
        &lt;div&gt;
            SharedMessage:
            {{sharedState.sharedMessage}}
            &lt;br/&gt;
            &lt;input v-bind:value=&quot;sharedState.sharedMessage&quot;
                   v-on:input=&quot;setSharedMessage($event.target.value)&quot;
            /&gt;
        &lt;/div&gt;
    `
})</code></pre><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h3><p>状态分布在 Vue 系统的各个组件中，这些状态通过 Vuex 解析成一个单一的状态树。一个 state 对象就包含了应用的全部层级状态。 </p>
<p>在入口文件中（main.js)，将 store 对象作为根实例 <code>app</code> 的一个选项：  </p>
<pre><code>const store = new Vuex.Store(Store) // 这里假设 Store 是模块系统导入的  

new Vue({
    store, // store: store 的简写
    render:h =&gt; h(App)
}).$mount(&apos;#app&apos;)  </code></pre><p>这样，通过根实例的 <code>store</code> 选项，所有的子组件将其作为实例属性，通过 <code>this.$store</code> 来访问全局的单例 store 。通常，store 中的属性会作为组件中的计算属性，改变这些属性的 <code>Action</code> 会由组件中的 <code>methods</code> 中的方法来提交。</p>
<p>例如：  </p>
<pre><code>const Counter = {
    template: `
        &lt;div&gt;{{count}}
    `,
    computed:{
        count(){
            return this.$store.state.count
        }
    },
    methods:{
        increment(){
            this.$store.commit(&apos;increment&apos;)
        }
    }
}</code></pre><p><strong>Tips:</strong>  </p>
<ol>
<li><p>当一个组件需要多个状态的时候，为了避免重复的为每一个状态声明计算属性，可以使用一个 <code>mapState</code> 的辅助函数来解决这个问题：  </p>
<pre><code>import { mapState } from &apos;vuex&apos; // 对象解构

export default{
    name: &apos;Counter&apos;,
    computed: mapState({
        // 在这个辅助函数中，
        // 可以访问将state作为函数的参数以访问 this.$store.state
        count: state=&gt;state.count,
        // 可以将 state 中的状态作为字符串参数，等同于 this.$store.state
        // 这里将其作为组件计算属性的别名
        countAlias: &apos;count&apos;,
        // 通过使用普通函数，访问组件实例 this
        countPlusLocalCount(state) {
            return state.count + this.localCount
        }
    })
}  

// 还可以在 mapState 函数中传入一个字符串数组，
// 将 state 中的状态作为组件中的计算属性

computed: mapState([&apos;count&apos;])</code></pre></li>
<li><p>既想要组件私有的计算属性，由想要共有的状态时，可以使用对象展开运算符 <code>...</code> ,将状态混入到计算属性对象中：  </p>
<pre><code>computed: {
    localComputed(){
        /*...*/
    },
    ...mapState(){
        /*...*/
    }
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Router/vue-router-advanced/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Router/vue-router-advanced/" class="post-title-link" itemprop="url">Vue Router 进阶</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-26 18:35:38" itemprop="dateCreated datePublished" datetime="2020-01-26T18:35:38+08:00">2020-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Router/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Router</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-Router-进阶"><a href="#Vue-Router-进阶" class="headerlink" title="Vue Router 进阶"></a><strong>Vue Router 进阶</strong></h1><p>这篇文章包含 Vue Router 的进阶内容，以及自己的经验总结。  </p>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a><strong>导航守卫</strong></h2><p>在应用中的页面 URL 改变的时候，Vue Router 提供了一系列的钩子函数来处理路由改变过程中需要<br>处理的逻辑。这些钩子函数就是导航守卫，这里的导航是指：<em>当前的路由发生了改变（也就是说页<br>面的 URL 发生了改变）</em>。  </p>
<p>需要注意的是，<strong>路由中参数，或者查询的改变并不会影响进入/离开的导航守卫</strong>。这时想要应对这些<br>变化，需要观察 <code>$route</code> 对象或者使用 <code>beforeRouteUpdate</code> 导航守卫。  </p>
<p>导航守卫根据作用域的不同分为：  </p>
<ul>
<li>全局守卫</li>
<li>路由独享守卫</li>
<li>组件内守卫</li>
</ul>
<h2 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a><strong>全局守卫</strong></h2><p>全局守卫在所有的路由变换时都可以被触发。按照触发时间不同被分为：  </p>
<ul>
<li>全局前置守卫</li>
<li>全局解析守卫</li>
<li>全局后置钩子  </li>
</ul>
<h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a><strong>全局前置守卫</strong></h3><p>使用 <code>router.beforeEach()</code> 可以注册一个全局前置守卫：  </p>
<pre><code>const router = new VueRouter({
    routes
})
router.beforeEach((to, from, next)=&gt;{
    // ...
})</code></pre><p>可以注册一个或者多个这样的守卫，当一个导航被触发的时候，这些守卫按照创建的顺序依次被调用<br>守卫们时异步解析执行，在所有守卫解析完成前路由的变化过程会一直处于 <strong>等待中</strong><br>每一个守卫方法接受三个参数：  </p>
<ul>
<li><code>to:Route</code> : 即将要进入的 路由对象  </li>
<li><code>from:Route</code> : 当前导航正要离开的路由对象  </li>
<li><code>next : Function</code> : <strong>这个方法必须被调用从而保证这个钩子被成功解析</strong>  <ul>
<li><code>next()</code>:进行管道中的下一个钩子。如果所有的导航钩子执行完了，则导航的状态则是： <strong>conformed</strong>。</li>
<li><code>next(false)</code> ：中断当前的导航。如果当前的 URL 改变了，URL 会被重置到 <code>from</code> 路由对应的位置。  </li>
<li><code>next(&#39;/&#39;)</code> 或者 <code>next({path:&#39;/&#39;})</code> : 跳转到一个不同的地址，当前的导航被中断，然后进入一个新的导航。</li>
<li><code>next(Error)</code> ： 传入一个 <code>Error</code> 实例， 导航被终止并将错误传递到 <code>router.onError()</code> 注册过的回调函数。  </li>
</ul>
</li>
</ul>
<h3 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a><strong>全局解析守卫</strong></h3><p>使用 <code>router.beforeResolve</code> 来注册一个全局解析守卫。它的作用和全局前置守卫类似，唯一的区别是全局解析守卫的触发时间是在当前导航被确认之前，在所有的组件和组件内守卫解析完毕时才被调用。  </p>
<h3 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a><strong>全局后置守卫</strong></h3><p>顾名思义，全局后置守卫在当前的路由离开的时候被触发。这种守卫不会接受 <code>next</code> 函数作为回调，也不会改变导航本身。  </p>
<h2 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a><strong>路由独享的守卫</strong></h2><p>在路由对象中可以配置这个路由独享的导航守卫：  </p>
<pre><code>const router = new VueRouter({
    routes: [
        {
            name:&apos;foo&apos;,
            path:&apos;/foo&apos;,
            component:Foo,
            beforeEnter: (to, from, next)=&gt;{
                //...
            }
        }
    ]
})</code></pre><h2 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a><strong>组件内的守卫</strong></h2><p>可以在组件内直接定义这些导航守卫：  </p>
<ul>
<li><code>beforeRouterEnter</code></li>
<li><code>beforeRouterUpdate</code></li>
<li><code>beforeRouterLeave</code></li>
</ul>
<p><code>beforeRouterEnter</code> 守卫不能直接访问组件实例 <code>this</code> ，因为在触发这个钩子函数的时候，这个组件还没有被创建。  </p>
<p>不过可以在这个钩子的 <code>next</code> 参数中接受一个 <code>vm</code> 组件对象作为当前组件实例。在导航被确认的时候执行这个回调函数：  </p>
<pre><code>beforeEnter: (to, from, next)=&gt;{
    next(vm=&gt;{
        // 这个vm作为当前的组件实例
    })
}</code></pre><p>其他两个组件内守卫因为被触发的时候组件已经被创建，所以可以访问 <code>this</code>。</p>
<h2 id="完整的导航解析过程"><a href="#完整的导航解析过程" class="headerlink" title="完整的导航解析过程"></a><strong>完整的导航解析过程</strong></h2><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Base/render-and-JSX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Base/render-and-JSX/" class="post-title-link" itemprop="url">渲染函数和 JSX</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-25 21:55:00" itemprop="dateCreated datePublished" datetime="2020-01-25T21:55:00+08:00">2020-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="渲染函数和-JSX"><a href="#渲染函数和-JSX" class="headerlink" title="渲染函数和 JSX"></a><strong>渲染函数和 JSX</strong></h1><p>vascript 框架，这也是 Vue 简单易学的原因。然而有些时候，我们需要<br>Javascript 完全编程的能力，可以使用 Vue 提供的 <strong>渲染函数（render）</strong> 来做到这一点。</p>
<h2 id="节点、树以及虚拟-DOM"><a href="#节点、树以及虚拟-DOM" class="headerlink" title="节点、树以及虚拟 DOM"></a><strong>节点、树以及虚拟 DOM</strong></h2><p>Vue 使用的元素（组件）节点和原生的 DOM 节点是不一样的，这个节点被 Vue 加工过，包含了<br>这个节点的和它的子节点的信息。 这样的节点叫做”虚拟节点“（virtual node），所谓的虚拟 DOM<br>就是由这些虚拟节点构成的 DOM 树所构成。</p>
<h3 id="createElement-参数"><a href="#createElement-参数" class="headerlink" title="createElement 参数"></a><strong><code>createElement</code></strong> 参数</h3><p>在 <code>render</code> 函数中，通常使用 <code>createElement</code> 函数来创建虚拟节点，下面是这个函数所接受的参数  </p>
<pre><code>/**
* @return {VNode}
*/
createElement(
    /**
    * @param {String | Object | Function}
    * 一个 Html 标签名、组件对象或者解析了上述任意
    * 一种的 async 函数，必填项
    */
    ’div&apos;,
    /**
    * @param {Object}
    * 一个对应模板属性的数据对象，例如 props，data 等，可选
    */
    {
        // props: {}    
        // data: function(){}
    },
    /**
    * @param {String | Array}
    * 子级虚拟节点列表
    * 也可以由子级文本字符串构成
    */
    [
        &quot;strings&quot;,
        // createElement()
    ]
)</code></pre><p>需要<strong>注意</strong>的是，一个组件的中的所有 VNode 必须是唯一的，也就是所有的 VNode 都应该是一个独立<br>对象。当我们想要渲染多个重复的 VNode 的时候，我们可以使用工厂函数，例如：</p>
<pre><code>createElement(
    &apos;div&apos;,
    Array.apply(null, {length:20}) 
        .map(()=&gt;{
            return createElement(
                &apos;p&apos;,
                &apos;hi&apos;
            )
        })
)</code></pre><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a><strong>使用插件</strong></h2><p><code>Vue.use()</code> 使用插件。需要在调用 <code>new Vue()</code> 启动应用之前完成。</p>
<h2 id="使用过滤器"><a href="#使用过滤器" class="headerlink" title="使用过滤器"></a><strong>使用过滤器</strong></h2><p>Vue 可以自定义过滤器，用于一些常见的文本格式化。过滤器一般用在两个地方: 模板表达式中，和<code>v-bind</code><br>表达式中。过滤器应该被添加在表达式的尾部，由管道符号（<code>|</code>）表示。  </p>
<p>例如：</p>
<pre><code>{{ message | capitalize}} &lt;!-- 首字母大写 --&gt;

&lt;div v-bind:id = &quot;rawId | formatId&quot;&gt;</code></pre><p>过滤器可以被定义在 Vue 实例的 <code>filters</code> 选项下作为一个组件过滤器：</p>
<pre><code>filters: {
    capitalize: function(value){
        if(!value) return &apos;&apos;;
        value = value.toString();
        return value.charAt(0).toUppercase() + value.slice(1);
    }
}</code></pre><p>也可以被定义为全局过滤器：</p>
<pre><code>Vue.filter(&apos;capitalize&apos;, function(value){
    if(!value) return &apos;&apos;;
        value = value.toString();
        return value.charAt(0).toUppercase() + value.slice(1);
})</code></pre><p>需要<strong>注意</strong>的是  </p>
<ul>
<li>当全局过滤器和局部过滤器重名的时候，会优先使用局部过滤器</li>
<li>过滤器会始终将表达式的值作为第一个参数</li>
<li>过滤器可以接受参数，例如：<code>message | capitalize(arg0, arg1)</code>, 但是该函数的第一个参数是 <code>message</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Router/vue-router-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Router/vue-router-base/" class="post-title-link" itemprop="url">Vue Router 基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-25 20:44:00" itemprop="dateCreated datePublished" datetime="2020-01-25T20:44:00+08:00">2020-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Router/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Router</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h1><p>Vue Router 作为 Vue.js 的官方路由器，主要应用在大型单页应用的路由管理。<br>Vue Router 拥有以下功能：</p>
<ul>
<li>嵌套的路由 / 视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 的过度系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 Css Class 的链接</li>
<li>Html5 历史模式或者 Hash 模式</li>
<li>自定义的滚动条行为</li>
</ul>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a><strong>基础使用</strong></h2><p>在模块化的构建系统中，例如 webpack ，要使用 Vue Router 需要先安装：</p>
<pre><code>npm install vue-router</code></pre><p>这样 vue-router 作为 Vue 的一个插件来使用，在 main.js （入口文件）中需要先使用这个插件  </p>
<pre><code>import VueRouter from &quot;vue-router&quot;

Vue.use(VueRouter)</code></pre><p>这样在整个 app 环境中，都可以使用这个插件。</p>
<p>要使用 Vue Router，应该首先定义一个路由器的列表，像下面这样：  </p>
<pre><code>const routes = [
    {
        path: &apos;/foo&apos;, // url path ，即路由路径
        component: AComponent // 一个组件对象，可以从其他文件中导入
    },
    {
        path: &apos;/bar&apos;,
        component: AnotherComponent // 另一个组件对象
    }
]</code></pre><p>然后可以在入口文件 main.js 中使用这个列表对象（导入），新建一个 VueRouter 对象：  </p>
<pre><code>const router = new VueRouter({
    routes // 等效于：routes:routes
})</code></pre><p>最后将这个 <code>router</code> 注册为 app 的选项：  </p>
<pre><code>new Vue({
    router,
    render: h=&gt;h(App)
}).$mount(&quot;#app&quot;)</code></pre><p>在模板中，  </p>
<ul>
<li>使用 <code>&lt;router-link to=&quot;url&quot;&gt;</code> 标签为一个路由设置路径，其中，<code>to</code> 属性是路由的路径<br>这个标签会被默认渲染成一个 <code>&lt;a&gt;</code> 标签。</li>
<li>使用 <code>&lt;router-view&gt;</code> 标签定义路由的出口，路由匹配到的组件将会渲染在这里面。  </li>
</ul>
<p>通过注入路由器，可以使用：</p>
<ul>
<li><code>this.$router</code> 访问路由器</li>
<li><code>this.$route</code>  访问当前路由</li>
</ul>
<h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a><strong>动态路由匹配</strong></h2><p>可以在路由参数的 <code>path</code> 属性中为一个路由设置动态路径，形如这样：  </p>
<pre><code>{
    path: &apos;/user/:id&apos;,
    component: User
}</code></pre><p>这样，所有的形如：/user/8 、/user/7 这样的 url 都将映射到相同的路由。  </p>
<p>当匹配到一个路由的时候，参数值会被设置到 <code>this.$route.params</code>, 这样就能够在每一个组件中<br>访问这个参数，上面例子中的 <code>User</code> 组件就可以利用这个参数，更新这个组件的模板。   </p>
<p>也可以为一个动态路由设置多个“路径参数”， 对应的值会设置到 <code>$route.params</code> 中, 例如：  </p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>匹配路径</strong></th>
<th><strong>route.params</strong></th>
</tr>
</thead>
<tbody><tr>
<td>/user/:username</td>
<td>/user/llp</td>
<td><code>{username: &#39;llp&#39;}</code></td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/llp/post/113</td>
<td><code>{username: &#39;llp&#39;, post_id: &#39;123&#39;}</code></td>
</tr>
</tbody></table>
<h2 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a><strong>响应路由参数的变化</strong></h2><p>使用路由参数在渲染不同的组件切换时候，<strong>原来的组件实例会被复用</strong>，这意味着<strong>组件的生命周期<br>钩子不会再被调用</strong>。</p>
<p>这个时候想要让组件对路由参数的变化做出响应的时候，可以利用 <code>watch</code> 选项检测 <code>$route</code> 的变化。 </p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a><strong>嵌套路由</strong></h2><p>嵌套路由用来解决组件嵌套中的动态路径，例如：  </p>
<p>路径：/user/foo/[profile] profile是动态路径的变量<br>组件：  </p>
<pre><code>&lt;user-component&gt;
    &lt;foo&gt;
        &lt;profile1/&gt;
    &lt;foo&gt;
&lt;/user-component&gt;</code></pre><p>一个渲染后的组件可以拥有自己的嵌套 <code>&lt;router-view&gt;</code>，要在嵌套的路由出口中渲染组件，需要在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置，例如：  </p>
<pre><code>const router = new VueRouter({
    routes: [
        {
            path: &apos;user/:id&apos;,
            component: User,
            children: [
                {
                    path:&apos;profile&apos;,
                    component: UserProfile
                }
            ]
        }
    ]
})</code></pre><p>可以看出，<code>children</code> 选项中的元素任然是一系列 <em>路由配置对象</em>。<br>需要<strong>注意</strong>的是：<br><code>children</code> 配置对象中的 <code>path</code> 如果以 <code>/</code> 开头，这个嵌套路径会被当做整个域的根路径。 </p>
<p>当没有匹配到嵌套路由的时候，我们有时候可能想要渲染一个默认的组件，这个时候可以设置一个空<br>路由：  </p>
<pre><code>children: [
    path: &apos;&apos;,
    component: DefaultComonent
]  </code></pre><h2 id="编程式的路由导航"><a href="#编程式的路由导航" class="headerlink" title="编程式的路由导航"></a><strong>编程式的路由导航</strong></h2><p>因为可以在 Vue 组件实例中访问路由实例 <code>this.$router</code> ，所以可以在 Vue 实例中编写路由导航，实现 <code>&lt;route-link&gt;</code> 标签功能。  </p>
<p><font size="4"><code>this.$router.push(location, onComplete?, onAbort?)</code></font></p>
<p>导航到不同的 URL，可以使用 <code>router.push</code> 方法。该方法向 histroy 栈中添加一个新的记录，<code>&lt;route-link&gt;</code> 标签的内部实现原理也是使用该方法。</p>
<table>
<thead>
<tr>
<th><strong>声明式</strong></th>
<th><strong>编程式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link to=&quot;...&quot;&gt;</code></td>
<td><code>this.$router.push({...})</code></td>
</tr>
</tbody></table>
<h3 id="push函数中的参数"><a href="#push函数中的参数" class="headerlink" title="push函数中的参数"></a><strong>push函数中的参数</strong></h3><ul>
<li><p>history  </p>
<ol>
<li><p>可以是一个字符串  </p>
<p>   字符串对象表示一个字符串路径  </p>
</li>
<li><p>可以是一个对象</p>
<p>   对象表示一个描述地址的对象，这个对象中的参数可以有：</p>
<p>   <code>name</code> : 一个字符串路径, 只能表示根路径下一级路径名，配合 <code>params</code> 使用<br>   <code>path</code> : 一个字符串路径，可以完整表示一个路径。使用后，<code>param</code> 属性会被忽略<br>   <code>params</code> : 动态路径参数，一个参数对象<br>   <code>query</code> : 查询参数，一个参数对象  </p>
</li>
</ol>
</li>
<li><p>onComplete : 一个导航成功后的回调函数</p>
</li>
<li><p>onAbort : 导航到相同路径或在当前导航完成之前导航到另一个不同的路由进行的调用（请求分发）</p>
</li>
</ul>
<p><em>Tips</em>：  </p>
<p>如果该函数中未指定后面两个回调参数，该函数返回的是一个 <code>Promise</code>， 相应的回调可以在 <code>then</code><br>(onComplete), <code>catch</code> (onAbort) 中定义。</p>
<p><font size="4"><code>this.$router.replace(location, onComplete?, onAbort?)</code></font></p>
<p>作用和 <code>router.push()</code> 一样，唯一的不同就是，它不会像 <code>histroy</code> 添加新纪录，而是替换掉当前的 <code>histroy</code> 记录。  </p>
<table>
<thead>
<tr>
<th><strong>声明式</strong></th>
<th><strong>编程式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link v-bind:to=&quot;...&quot; replace&gt;</code></td>
<td><code>router.replace(...)</code></td>
</tr>
</tbody></table>
<p><font size="4"><code>this.$router.go(n)</code></font>  </p>
<p>这个方法的参数式一个参数，意思是在 <code>histroy</code> 记录中向前进或者向后退多少步，类似 <code>window.histroy.go(n)</code> 。  </p>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a><strong>命名路由</strong></h2><p>在配置路由器的时候，路由对象中的 <code>name</code> 属性，可以为这个路由配置一个名字，当链接一个路由<br>或者在执行某些跳转的时候，就显得很方便了。例如：  </p>
<pre><code>const router = new VueRouter({
    routes: [
        {
            path: &apos;/user/:userId&apos;,
            name: &apos;user&apos;,
            component: User
        }
    ]
})</code></pre><p>要链接一个路由，可以给 <code>&lt;router-link&gt;</code> 标签中的 <code>to</code> 属性传递一个对象：  </p>
<pre><code>&lt;router-link v-bind:to=&quot;{name: &apos;user&apos;, params:{userId: 123}}&quot;&gt;User&lt;/router-link&gt;</code></pre><p>类似的，<code>$router.push()</code> 方法作用是一样的：  </p>
<pre><code>$router.push({name:&apos;user&apos;, params:{userId:123}})  </code></pre><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a><strong>命名视图</strong></h2><p>如果想在同一级展示多个视图，而不是嵌套视图，可以将路由器配置对象中的 <code>component</code> 换成<br><code>components</code>, 使之成为一个组件。这些组件可以对应多个视图，如果要让路由出口与组件对<br>应，应该给 <code>&lt;router-view&gt;</code> 配置一个 <code>name</code> 属性，如果没有名字，其默认名字为 <code>default</code>。设置好名字后，可以在路由器配置中分别配置对应名字的组件。例如：  </p>
<pre><code>const router = new VueRouter({
    routes:[
        {
            path: &apos;/&apos;,
            components:{
                default:Foo,
                nameA: Bar,
                nameB: FooBar
            }
        }
    ]
})</code></pre><h3 id="嵌套命名视图"><a href="#嵌套命名视图" class="headerlink" title="嵌套命名视图"></a><strong>嵌套命名视图</strong></h3><p>当我们将嵌套视图和命名视图的用法结合起来的时候，可以实现更好的功能。</p>
<p>例如：  </p>
<pre><code>{
    path:&apos;/settings&apos;,
    component: UserSettings,
    children:[
        {
            path:&apos;emails&apos;, // /settings/emails
            component: UserEmailSetting
        },
        {
            path: &apos;profile&apos;,
            components:{
                default: UserProfile,
                helper: UserProfilePreview
            }
        }
    ]
}

&lt;div&gt;
    &lt;h1&gt;User Settings&lt;/h1&gt;
    &lt;NavBar/&gt;
    &lt;router-view/&gt;
    &lt;router-view name=&apos;helper&apos;&gt;
&lt;/div&gt;</code></pre><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a><strong>重定向和别名</strong></h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a><strong>重定向</strong></h3><p>当我们访问一个 url 地址的时候，我们实际上想让浏览器跳转到另一个地址，可以使用重定向的功能  </p>
<p>具体的用法是在路由配置对象中添加一个 <code>redirect</code> 参数，例如：  </p>
<pre><code>{
    path: &apos;/a&apos;,
    component: ComponentA,
    redirect: &apos;/b&apos;
}</code></pre><p>这样，当我们访问 <code>/a</code> 的时候，浏览器会跳转到 <code>/b</code> </p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a><strong>别名</strong></h3><p>与重定向不同的是，别名的用法为：</p>
<pre><code>{
    path: &apos;/a&apos;,
    component: ComponetA,
    ailas: &apos;/b&apos;
}</code></pre><p>这样当我们访问 <code>/b</code> 的时候，URL会映射为 <code>/b</code> ,但是路由将会映射到 ‘/a’。  </p>
<p>别名的作用： 可以自由的将 UI 结构映射到任意结构的 URL，而不是受限于配置的嵌套路由结构。  </p>
<h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a><strong>路由组件传参</strong></h2><p>在组件中使用 <code>$route</code> 来获取当前路由的路由参数，会造成组件和路由的高度耦合，不利于组件<br>的复用。因此，可以在路由配置对象中设置 <code>props</code> 选项，利用 prop 将路由参数传递给组件，这<br>样组件就可以在任何地方使用。  </p>
<p>例如：  </p>
<pre><code>const User = {
    props: {
        id: Number
    },
    template: `
        &lt;div&gt;User {{id}} &lt;/div&gt;
    `
}

const router = new VueRouter({
    routes:[
        {
            path: &apos;/user/:id&apos;, 
            component: User,
            props: true // 布尔参数将会设置路由参数为 prop
        },

        // 对于命名视图，需要在 props 选项中为每一个命名视图设置
        {
            path: &apos;/user/:id&apos;,
            component: {
                default: User,
                sideBar: SideBar
            },
            props: {
                default: true,
                sideBar: false
            }
        }
    ]
})</code></pre><h3 id="props-选项的几种模式"><a href="#props-选项的几种模式" class="headerlink" title="props 选项的几种模式"></a><strong>props 选项的几种模式</strong></h3><p>上面的例子已经展示了 props 选项作为布尔值的作用，props 一共可以设置一下几种模式  </p>
<ul>
<li><p>布尔模式  </p>
<p>当 props 选项设置为布尔值的时候的时候，当值为 <code>true</code> 时 <code>$route.params</code><br>将会设置为组件的prop</p>
</li>
<li><p>对象模式  </p>
<p>当props 选项被设置为对象的时候，这个对象将会按照原样被设置为组件的 prop ，例如</p>
<pre><code>const router = new VueRouter({
    routes:[
        {
            path:&apos;/user/:id&apos;,
            component: User,
            props:{
                show: false
            }
        }
    ]
})</code></pre><p>  这样 <code>{show:false}</code> 这个对象将会作为组件的 prop 传递给组件，当需要传递的 prop 是静态的时候使用。</p>
</li>
<li><p>函数模式  </p>
<p>当 props 选项是一个函数的时候，组件将会将函数的返回值作为 prop。当需要基于路由的值<br>转换为另一个对象的的时候可以利用这个模式。  </p>
</li>
</ul>
<p><strong>需要注意的是</strong>  </p>
<p>最好将传递的 prop 设置为静态的值，因为它只会在路由发生变化的时候才会改变。  </p>
<h2 id="H5-Histroy-模式"><a href="#H5-Histroy-模式" class="headerlink" title="H5 Histroy 模式"></a><strong>H5 Histroy 模式</strong></h2><p>VueRouter 默认使用 hash 模式，这个模式使用当前的 URL 来模拟生成一个完整的 URL，当 URL 改变的时候，页面不会重新加载。  </p>
<p>这种模式的特点就是在当前 URL 的末尾生成一个 # 符号。例如：  </p>
<pre><code>https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90</code></pre><p>为了去掉这个 # ,可以使用 <strong>history</strong> 模式。这种模式下，浏览器的 URL 就像正常的 URL 一样。  </p>
<p>需要注意的是，在这种模式下，后台需要正确的配置。因为如果页面是一个单页应用，一些不返回页<br>面的 URL 会返回 404。  </p>
<p>一个解决方案是：配置一个所有情况下的候选资源，如果找不到这个资源，至少应该返回 <code>index.html</code> 页面。这样需要在前端处理 404 等错误页面。  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Base/component/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Base/component/" class="post-title-link" itemprop="url">Vue 组件基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-25 20:39:00" itemprop="dateCreated datePublished" datetime="2020-01-25T20:39:00+08:00">2020-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>这篇文章概述了 Vue 的组件使用基础。更深入的组件了解 ==&gt; <a href="/yukino-blog/Vue/Vue-Base/advanced-component/"><strong>深入了解 Vue 组件</strong></a></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;组件是可以复用的 Vue 实例，它可以被重复使用很多次，每当使用一个组件，<br>就相当于 <code>new</code> 了一个新的 Vue 实例，所以它们名字相同的属性被各自维护。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>// 定义一个 button-counter 的新组件
Vue.component(&apos;button-counter&apos;, {
    data: function(){
        return {
            count:0
        }
    },
    template: &quot;&lt;button @click=&apos;count++&apos;&gt;click {{count}} {{count > 1 ? 'times' : 'time'}}&lt;/button&gt;
});
new Vue({el:&quot;component-demo&quot;});</code></pre><p>组件是可复用的 Vue 实例，且带有一个名字，可以在一个根 Vue 实例中以 html 标签的形，<br>使用这个组件。</p>
<pre><code>// 在根实例中使用这个组件
&lt;div id=&apos;component-demo&apos;&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt; // 组件可以复用多次
&lt;/div&gt;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>&emsp;&emsp;在注册组件的时候，data属性需要写成一个返回数据对象的函数，这样每个组件都有自己<br>各自的数据，这份数据不会被共享。如果不写成函数，那么每一个组件都共享一份数据。然而<br>组件应该是独立的。</p>
<p><em>正确的：</em>  </p>
<pre><code>Vue.component(&apos;button-counter&apos;, {   
    data: function(){   
        return {    
            count: 0    
        }   
    }   
})  </code></pre><p><em>错误的</em>  ‘</p>
<pre><code>Vue.component(&apos;button-counter&apos;, {
    data: {
        count: 0
    }
})</code></pre><p>&emsp;&emsp;在组件中书写字符串模板的时候，这个模板必须是一个单根元素（也就是有且仅有一个顶层<br>节点）。</p>
<p><em>正确的</em></p>
<pre><code>template: `
    &lt;div&gt;
        &lt;h2&gt; this is a title &lt;/h2&gt;
        &lt;p&gt;hello world&lt;/p&gt;
    &lt;/div&gt;
`</code></pre><p><em>错误的</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template: &#96;</span><br><span class="line">    &lt;h2&gt; this is a title &lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt; hello world &lt;&#x2F;p&gt;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>


<h2 id="通过prop传递数据"><a href="#通过prop传递数据" class="headerlink" title="通过prop传递数据"></a>通过prop传递数据</h2><h3 id="prop-的定义"><a href="#prop-的定义" class="headerlink" title="prop 的定义"></a>prop 的定义</h3><p>&emsp;&emsp;prop是一个可以在组件上注册的一些自定义属性。当一个值传递给一个prop特性的时候，它<br>就变成了那个组件实例的一个属性。例如，给一个博文组件传递一个标题，我们可以用一个<code>props</code><br>选项将其包含在该组件可接受的prop列表中</p>
<h3 id="使用prop"><a href="#使用prop" class="headerlink" title="使用prop"></a>使用prop</h3><p>&emsp;&emsp;在组件的定义中，props 字段作为一个prop列表，在模板中，可以使用这些prop。使用的方法<br>是：将父组件传递的数据绑定在prop中，那么这个组件的prop就可以作为一个独立的属性来使用。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(post-item, &#123;</span><br><span class="line">    props:[post],</span><br><span class="line">    template: &#96;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123;post.id&#125;&#125;. &#123;&#123;post.text&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">            &lt;&#x2F;br&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &#96;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&#39;component-prop&#39;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        postList:[</span><br><span class="line">            &#123;id:0, text:&quot;hello world&quot;&#125;,</span><br><span class="line">            &#123;id:1, text:&quot;awsome vue&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>###</p>
<pre><code>&lt;div id=&apos;component-prop&apos;&gt;
    &lt;post-item v-for=&quot;postItem of postList&quot;
               v-bind:post=&quot;postItem&quot;
               v-bind:key=&quot;postItem.id&quot;/&gt;
&lt;/div&gt;</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Base/animation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Base/animation/" class="post-title-link" itemprop="url">动画和过渡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 23:31:25" itemprop="dateCreated datePublished" datetime="2020-01-20T23:31:25+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动画和过度"><a href="#动画和过度" class="headerlink" title="动画和过度"></a>动画和过度</h1><p>这篇文章记录了 Vue 对动画和过度效果的支持，同时记录了我的一些理解</p>
<h2 id="组件的过渡"><a href="#组件的过渡" class="headerlink" title="组件的过渡"></a><strong>组件的过渡</strong></h2><p>Vue 提供了 <code>transition</code> 内置组件用于下列情形的任意元素的过渡：</p>
<ul>
<li>条件渲染（<code>v-if</code>)</li>
<li>条件展示（<code>v-show</code>)</li>
<li>动态组件（被 <code>component</code> 包裹的组件）</li>
<li>组件根节点</li>
</ul>
<p>被 <code>transition</code> 组件包裹的组件在插入或者删除的时候，Vue 会做下述护理：  </p>
<ol>
<li><p>自动探测 <code>transition</code> 组件是否应用了 css过渡或者动画，如果是，则在恰当的时机<br>添加或者删除相应的 class 类</p>
</li>
<li><p>如果过渡组件提供了相应的 Javascript 钩子函数，这些钩子函数会在恰当的时机被调用  </p>
</li>
<li><p>如果没有上述两种情况，则 DOM 操作会在下一帧立即执行，也就是说没有过渡的效果</p>
</li>
</ol>
<p>使用 <code>transition</code> 组件的方法是给这个组件定义一个 name 属性，这个属性会作为下面六种 Vue<br>内置的 CSS 过渡类的类名前缀，在样式表中探测是否存在这种格式的类，并在适当的时机为包裹<br>元素添加相应的类名。这六种过渡类分别是：  </p>
<ol>
<li><code>v-enter</code> : 定义了<strong>进入</strong>过渡的开始状态，也就是这个组件被插入之前的 class 类，这个class<br>在元素被插入之后的下一帧移除。  </li>
<li><code>v-enter-active</code> ：定义了<strong>进入</strong>过渡生效时的状态，这个 class 类在整个过渡过程的时候生<br>效，在过渡 / 动画完成后移除。这个类通常被用来设置过渡的效果，例如过渡时间，过渡<br>曲线等，动画类似。</li>
<li><code>v-enter-to</code> : 定义了<strong>进入</strong>过渡的结束状态。在元素被插入的下一帧生效，在过渡 / 动画完成<br>时候移除。</li>
<li><code>v-leave</code> : 定义了<strong>离开</strong>过渡的开始状态，对应 <code>v-enter-to</code> 的状态，在离开过渡触发生效，<br>下一帧被移除。</li>
<li><code>v-leave-active</code> ：定义了<strong>离开</strong>过渡的生效状态，同 <code>v-enter-active</code>。</li>
<li><code>v-leave-to</code> : 定义了<strong>离开</strong>过渡的结束状态，同 <code>v-enter</code>。</li>
</ol>
<p>下图展示了这六种 class 类的在整个过渡过程的生效时间：  </p>
<p><img src="/yukino-blog/images/transition.png" alt="transition"></p>
<p>需要注意的是，  </p>
<ol>
<li>这里的 v 前缀是当 <code>transition</code> 组件没有定义 <code>name</code> 属性的时候默认的。<br>当定义了 <code>name</code> 属性的时候，这个 v 会被替换为 <code>name</code> 所定义的内容。</li>
<li>css 动画的使用和过渡类似，唯一的区别是 <code>v-enter</code> 类名再节点被插入<br>时候不会被立即删除，而是在 <code>animationend</code> 事件触发的时候被删除。</li>
</ol>
<h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a><strong>自定义过渡的类名</strong></h3><p>当想要使用第三方 css 类库的时候，我们可以定义 <code>transition</code> 组件的内联样式属性：  </p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>这六个作为 <code>transition</code> 组件的属性具有最高优先级，可以和 Vue 的过渡系统结合起来。</p>
<h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a><strong>同时使用过渡和动画</strong></h3><p>当想要给过渡或者动画添加事件监听机制的时候，需要给 <code>transition</code> 组件添加相应的事<br>件监听器，过渡—— <code>transitionend</code>, 动画—— <code>animationend</code>。Vue 会根据具体的 CSS<br>识别并添加监听器。  </p>
<p>当同时使用这两种效果的时候。 需要在 <code>transition</code> 组件明确指定 <code>type</code> 这个属性并设置<br><code>transition</code> 或者 <code>animation</code> 来区分这两种动效。</p>
<h3 id="多个元素（组件）的过渡"><a href="#多个元素（组件）的过渡" class="headerlink" title="多个元素（组件）的过渡"></a><strong>多个元素（组件）的过渡</strong></h3><p>当一个 <code>transition</code> 组件包含多个元素（组件）的时候，且这些元素（组件）在同一时间<br>只渲染一个的时候，可以在 <code>transition</code> 组件中使用 <code>v-if</code>, <code>v-else</code>, 控制元素的渲染，用<br>动态组件控制组件的渲染。  </p>
<p>需要注意的是这些元素（组件）的切换的时候，它们的渲染模式在默认情况下是进入状态<br>和离开状态同时发生。这在某些情况下可能达不到预期的效果， Vue 提供了过渡模式，让<br>两个组件的渲染过渡拥有先后次序：  </p>
<ul>
<li><code>in-out</code> : 新元素先进行过渡，过渡完成后当前元素过渡离开</li>
<li><code>out-in</code> : 当前元素先进行过渡，过渡完成后新元素过渡进入  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/uncategorized/command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/uncategorized/command/" class="post-title-link" itemprop="url">Vue 指令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 23:30:25" itemprop="dateCreated datePublished" datetime="2020-01-20T23:30:25+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h1><p><strong>每学习一个指令，将其用法和自己的理解记录下来</strong></p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><strong>v-bind</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><code>v-bind</code> 指令是一个用于将 vue 实例中的数据属性或者prop动态地和 html 标签中的属性绑定<br>起来。当 vue 实例中的数据属性发生改变时，html 标签中的属性也会响应式的变化。  </p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><ul>
<li><p>缩写： <code>:</code></p>
</li>
<li><p>参数： <code>attr | prop</code></p>
</li>
<li><p>修饰符：  </p>
<ul>
<li><code>.prop</code> 待续</li>
<li><code>.camel</code> 待续</li>
<li><code>.sync</code> 待续</li>
</ul>
</li>
<li><p>说明：<br>  动态的绑定一个或多个属性，或用一个prop到表达式。  </p>
<p>  在绑定 <code>style</code> 或 <code>class</code> 特性时，支持其它类型的值，如数组或者对象。 </p>
<p>  在绑定prop时，prop必须在子组件中声明。可以用修饰符指定不同的绑定类型。  </p>
<p>  没有参数时，可以绑定一个包含键值对的对象。**注意，此时 <code>class</code> 和 <code>style</code> 绑定不支持数组或者对象。  </p>
<p>  <em>下面是我自己的理解：</em>  </p>
<ul>
<li>动态绑定一个属性的时候，将null值作为参数，将会取消这个绑定事件。</li>
</ul>
</li>
<li><p>示例  </p>
<pre><code>&lt;!-- 绑定一个属性 --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot;&gt;

&lt;!-- 动态特性名 (2.6.0+) --&gt;
&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;

&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;
&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 内联字符串拼接 --&gt;
&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;

&lt;!-- class 绑定 --&gt;
&lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;

&lt;!-- style 绑定 --&gt;
&lt;div :style=&quot;{ fontSize: size + &apos;px&apos; }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;

&lt;!-- 绑定一个有属性的对象 --&gt;
&lt;div v-bind=&quot;{ id: someProp, &apos;other-attr&apos;: otherProp }&quot;&gt;&lt;/div&gt;

&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;
&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;

&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;
&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;

&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;
&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;

&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</code></pre></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Base/instance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Base/instance/" class="post-title-link" itemprop="url">Vue 实例</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 23:21:25" itemprop="dateCreated datePublished" datetime="2020-01-20T23:21:25+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h1><h2 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h2><p>每一个 Vue 应用都是通过 <code>Vue</code> 函数创建一个新的 Vue 实例开始的  </p>
<pre><code>var vm = new Vue({
    // 选项
});  </code></pre><p>当创建一个 Vue 实例时，可以传入一个选项对象。<br>每一个 Vue 应用通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的，嵌套的、可复用的<em>组件</em> 树<br>组成。</p>
<h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据作为一个 Vue 实例的属性，当这个属性被改变时，视图将会产生响应(也就是同步的改变)，因为这个属性被加入到了 Vue 的响应式系统中了。</p>
<p>为一个 Vue 实例添加数据的方式如下:  </p>
<pre><code>var vm = new Vue({
    data: {
        msg: &quot;hello vue!&quot;
    }
});</code></pre><p>这样就为 vm 这个 Vue 实例添加了一个属性名为 msg 的数据，他的值为 “hello vue” 。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法作为一个 vue 实例的方法，通过在 vue 实例中定义它们，就可以在一些需要动态改变数据的地方用<br>到这些方法</p>
<p>为一个 Vue 实例添加方法的方式如下：</p>
<pre><code>var vm = new Vue({
    data: {
        msg: &quot;hello vue&quot;
    },
    methods: {
        reverseMsg: function(){
            this.msg = this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;);
        }
    }
});</code></pre><p>这里为 vm 这个 vue 实例添加了一个 <code>reverseMsg</code> 的方法,  这个方法将实例中的msg属性这个字符串反<br>转了</p>
<blockquote>
<p><strong><font color='red' size='4'>注意</font></strong><br>不要在选项属性或回调上使用箭头函数，比如 <code>created: () =&gt; console.log(this.a)</code><br>或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<br><code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught   
TypeError: Cannot read property of undefined</code>或 <code>Uncaught TypeError:  
this.myMethod is not a function</code> 之类的错误。</p>
</blockquote>
<h2 id="Vue-实例的生命周期"><a href="#Vue-实例的生命周期" class="headerlink" title="Vue  实例的生命周期"></a>Vue  实例的生命周期</h2><p><img src="/yukino-blog/images/vue-instance-lifecycle.png" alt="Vue实例生命周期示意图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/Vue/Vue-Base/advanced-component/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/Vue/Vue-Base/advanced-component/" class="post-title-link" itemprop="url">深入了解 Vue 组件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-20 22:57:25" itemprop="dateCreated datePublished" datetime="2020-01-20T22:57:25+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 00:07:31" itemprop="dateModified" datetime="2020-01-28T00:07:31+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a><strong>深入了解组件</strong></h1><p>这篇文章记录组件的高级知识，和自己对组件的总结。</p>
<h2 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a><strong>组件的注册</strong></h2><p>&emsp;&emsp;组件的注册包括全局注册和局部注册两种。</p>
<ul>
<li><p>全局注册  </p>
<p>  即通过 <code>Vue.component({/\*\*...\*\*/})</code> 来注册组件。<br>  全局注册的组件可用于任何新创建的 Vue 实例，也包括组件之间相互的使用。</p>
</li>
<li><p>局部注册  </p>
<p>  全局注册的组件，即便不想使用这个组件，它任然会包含在构建结果中。这造成了<br>  用户下载的 JavaScript 的无谓的增加。<br>  通过使用局部组件，可以避免这个问题。局部注册的方法如下：  </p>
<pre><code>// 通过使用变量，将组件的引用赋值给一个变量
var ComponentA = { /\* ... \*/ }
var ComponentB = { /\* ... \*/ }
// 然后在一个 Vue 实例中的 components 定义你想使用的组件
new Vue({
    el: &quot;#app&quot;,
    components: {
        &apos;component-a&apos; : ComponentA,
        &apos;component-b&apos; : ComponentB
    }
})</code></pre><p>  需要<strong>注意</strong>的是：  </p>
<ul>
<li>对于 <code>components</code> 对象中的每一个属性来说，其属性名就是自定<br>义元素的名字，其属性值就是某一个组件的变量名。</li>
<li>局部注册的组件在其子组件中不可用。如果想要在子组件中使用，<br>需要在子组件中注册这个组件。 </li>
</ul>
</li>
</ul>
<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a><strong>Prop</strong></h2><h3 id="prop-的类型"><a href="#prop-的类型" class="headerlink" title="prop 的类型"></a><strong>prop 的类型</strong></h3><p>通常prop的传递通过字符串数组的形式，比如这样：  </p>
<pre><code>props:[&apos;prop1&apos;, &apos;prop2&apos;, &apos;prop3&apos;]</code></pre><p>但是，通常我们希望每一个 <code>prop</code> 都有自己指定值的类型。这时，我们可以用对象的形式<br>列出 <code>prop</code>，这些属性的名称和值分别是prop各自的名称和类型。这样也可以对 prop。<br>进行类型检查。例如：  </p>
<pre><code>props: {
    title: String,
    likes: Number,
    isPublished: Boolean
}</code></pre><h3 id="prop-的传递应该是一个单向数据流"><a href="#prop-的传递应该是一个单向数据流" class="headerlink" title="prop 的传递应该是一个单向数据流"></a><strong>prop 的传递应该是一个单向数据流</strong></h3><p>所有的prop都使得其父子prop之间形成了一个<strong>单向下行绑定</strong>：父级prop的更新会向下流动<br>到子组件中，但是反过来却不行。这样能够防止从子组件意外改变父级组件的状态，从而<br>导致应用的数据流向难以理解。</p>
<p>每次父级组件发生更新的时候，子组件中的所有prop都会刷新为最新的值。这意味着不应该<br>在一个子组件内部改变 prop。 </p>
<h3 id="非-prop-的-Attribute"><a href="#非-prop-的-Attribute" class="headerlink" title="非 prop 的 Attribute"></a><strong>非 prop 的 Attribute</strong></h3><p>一个非 prop 的 Attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的Attribute。<br>但是一个组件可以接受任意的 attribute ，<strong>而这个attribute会被添加到这个组件的根元素上</strong>。 </p>
<h3 id="替换-合并已有的-attribute"><a href="#替换-合并已有的-attribute" class="headerlink" title="替换/合并已有的 attribute"></a><strong>替换/合并已有的 attribute</strong></h3><p>对于绝大数的 attribute，外部提供给组件的值会替换掉组件内部根元素设定好了的值。但是<br>style 和 class 属性会合并两个值。</p>
<h3 id="禁用-attribute-继承"><a href="#禁用-attribute-继承" class="headerlink" title="禁用 attribute 继承"></a><strong>禁用 attribute 继承</strong></h3><p>当不希望一个组件内部的根元素(组件)继承外部的属性，那么可以将这个组件的 <code>inheritAttrs</code><br>属性设置为 <code>false</code>。例如：</p>
<pre><code>Vue.component(&apos;demo-component&apos;, {
    inheritAttrs: false,
    template: /* ... */
})</code></pre><p>这样书写给 <code>demo-component</code> 这个组件的属性就不会继承到它的子组件中。</p>
<p>值得注意的是，这样做的好处在于：<br>当一个组件的模板嵌套着很多子组件时，我们不希望配置给这个组件的属性直接继承在这个组件<br>的根组件上，而是继承给某一个我们希望的子组件上面。 </p>
<p>具体的做法是：  </p>
<ol>
<li>禁用属性继承（即 <code>inheritAttrs: false</code>）</li>
<li>将组件的实例属性 <a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener"><code>$attrs</code></a> , 绑定到指定的子组件或者元素上面  </li>
</ol>
<p>需要<strong>注意</strong>的是：  </p>
<p><code>inheritAttrs: false</code> 并<strong>不会</strong>影响到 style 和 class 的绑定。也就是说，这两个属性<br>还是会绑定在模板的根元素（子组件）上面。</p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a><strong>自定义事件</strong></h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a><strong>事件名</strong></h3><p>不同于组件和prop，事件名不会存在任何的自动化的大小写转换，而是触发的事件名必须<br>完全匹配这个事件所用的名称。  </p>
<p>建议始终使用短横线分割的小写标识符。</p>
<h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a><strong>自定义组件的 <code>v-model</code></strong></h3><p><code>v-model</code> 用在组件上面的时候，会默认利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，<br>当使用一些像单选框，复选框这样的输入表单控件的时候，这个指令就达不到我们想要<br>的效果。这个时候，我们可以使用 Vue 实例中的 <code>model</code> 选项用来避免这样的冲突。<br>例如：  </p>
<pre><code>Vue.component(&apos;base-checkbox&apos;, {
    model: {
        prop: &apos;checked&apos;,
        event: &apos;change&apos;
    },
    props: {
        checked: Boolean
    },
    template: `
        &lt;input type=&quot;checkbox&quot;
               :checked=&quot;checked&quot;
               @change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot;
        &gt;
    `
})</code></pre><p>这样当在 <code>base-checkbox</code> 这个组件上使用 <code>v-model</code> 的时候，将会创建一个和checked<br>双向绑定的响应式关系。</p>
<h3 id="使用-listeners-属性将原生事件绑定到组件中"><a href="#使用-listeners-属性将原生事件绑定到组件中" class="headerlink" title="使用 $listeners 属性将原生事件绑定到组件中"></a><strong>使用 $listeners 属性将原生事件绑定到组件中</strong></h3><p>绑定原生 DOM 事件的方法是在 <code>v-on</code> 这个指令上面加上 <code>.native</code> 这个修饰符。<br>但是，当在一个组件上绑定一个原生事件并且组件内部尝试监听一个特定的元<br>素的时候，父级的 .native 监听器将会失败。Vue 不会报错，但是相应的事件处<br>理函数将不会执行。  </p>
<p>这个时候，可以使用 Vue 提供的 $listeners 属性将组件上所有的事件监听器指<br>向这个组件上的指定元素。具体的方法是：</p>
<pre><code>// 例如我们想要将一个组件上面的 focus 事件监听器指向这个组件内部的一个 input 元素
Vue.component(&apos;base-input&apos;, {
    inheritAttrs: false,
    props: [&apos;input&apos;]
    computed: {
        inputListeners: function(){
            let vm = this;
            // 使用 Object.assign 方法将多个对象合并
            return Object.assign({}, 
                this.$listeners,
                {
                    input: function(){
                        vm.$emit(&apos;input&apos;, $event.target.value);
                    }
                }
            )
        }
    },
    template: `
        &lt;label&gt;
            &lt;input type=&quot;text&quot;
                   v-bind=&quot;$attrs&quot;
                   :input=&quot;input&quot;
                   v-on=&quot;inputListeners&quot;&gt;
        &lt;/label&gt;
    `
})</code></pre><p>这样使用 <code>base-input</code> 就相当于使用普通的 <code>input</code> 了，也就是说，这个组件<br>已经是透明的了。</p>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a><strong>插槽</strong></h2><h3 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a><strong>插槽的基本使用</strong></h3><p>当我们想要在一个组件中插入一段模板或者HTML的时候，可以使用 Vue 提供<br>的插槽机制。如果不使用插槽，并且在一个自定义组件中插入了一段模板或者<br>HTML的话，那么 Vue 将不会渲染这一部分的内容。</p>
<p>插槽的具体使用方式如下：</p>
<pre><code>// 假如这是一个名为 &lt;my-slot&gt; 组件的模板内容
&lt;label&gt;
    &lt;span&gt;你好&lt;/span&gt;
    &lt;slot&gt;&lt;/slot&gt;
&lt;/label&gt;</code></pre><p>###<br>可以像使用 html 元素一样使用这个组件</p>
<pre><code>&lt;my-slot&gt;
    Vue
&lt;/my-slot&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>经过 Vue 渲染后的结果为：</p>
<pre><code>你好Vue</code></pre><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a><strong>具名插槽</strong></h3><p>当想要使用多个插槽的时候，可以在 <code>&lt;slot&gt;</code> 元素上面添加一个 <code>name</code> 特性，这个<br>特性可以作为识别这个插槽的标识。然后在具体使用这个模板的时候，使用 <code>v-slot</code><br>指令，将 name 作为这个指令的参数，作用在一个模板组件 <code>&lt;template&gt;</code> 上面。那<br>么这个模板的内容将被填充在这个插槽里面。未使用 name 特性的 <code>&lt;slot&gt;</code> 将会有<br>一个默认的 name —— default。未使用 <code>&lt;template&gt;</code> 的内容将会视作默认插槽的内<br>容。使用这种方式定义的插槽叫做<strong>具名插槽</strong>。</p>
<p><strong>注：</strong><br>和其他可缩写指令一样，<code>v-slot</code> 指令可以缩写为 <code>#</code>, 但必须指定参数，也就是<br>说不能这样用：<code>#=</code></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a><strong>作用域插槽</strong></h3><p>当想在父级组件作用域中使用子组件中作用域中的数据的时候，可以使用 Vue 提供的<br>作用域插槽的解决方案。<br>具体的使用方法如下：</p>
<pre><code>// 假如在父级组件或者 rawHtml 中需要使用一个叫做 isCompleted 的属性
// 这是子组件
var todoList = {
    props:{
        todoItems: Array
    },
    computed: {
        filteredTodoItems: function(){
            return this.todoItems.filter(item =&gt; item.title);
        }
    },
    // 绑定在&lt;slot&gt;标签中的特性被称为插槽 prop , 这个prop在父级作用域中
    // 可以通过 v-slot 指令提供的插槽 prop 名字来访问
    template: `
        &lt;ul&gt;
            &lt;li v-for=&quot;item of filteredTodoItems
                :key=&quot;item.id&quot;&gt;
                &lt;slot v-bind:todo=&quot;item&quot;&gt;
                    {{item.title}}
                &lt;/slot&gt;
                &lt;input type=&quot;checkbox&quot; v-model=&quot;item.isCompleted&quot;&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    `
};

new Vue({
    el:&quot;#component-slot-prop&quot;,
    data: {
        todoItems: [
            {
                id: 0,
                title: &quot;学习 Vue 的插槽用法&quot;,
                isCompleted: false
            },
            {},
            {
                id: 3,
                title: &quot;学习 JVM 的知识&quot;,
                isCompleted: false
            }
        ]
    },
    components: {
        &quot;todo-list&quot;: todoList
    }
});

// 在父级组件中访问这个插槽 prop，根据 isCompleted 的值来条件渲染
&lt;div id=&quot;component-slot-prop&quot;&gt;
&lt;!-- 这里使用解构对象给 v-slot 指令赋值 --&gt;
    &lt;todo-list v-slot=&quot;{ todo }&quot;
               :todo-items=&quot;todoItems&quot;&gt;
        &lt;span v-if=&quot;todo.isCompleted&quot;&gt; ✔ &lt;/span&gt;
        {{todo.title}}
    &lt;/todo-list&gt;
&lt;/div&gt;</code></pre><p><strong>注：</strong><br>作用域插槽的更多用法 ==&gt; <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener" title="一个基于 Vue 的虚拟滑动器，旨在提高性能">Vue Virtural Scroller</a></p>
<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a><strong>动态组件 &amp; 异步组件</strong></h2><p>当我们想要根据条件，动态渲染某一个组件的时候，可以使用 Vue 提供的<br>动态组件功能。例如，当我们选择一个导航栏标题的时候，内容区域根据标<br>题的不同使用不同的组件。</p>
<p>具体的做法是使用一个 Vue 提供的内置组件 <code>&lt;component&gt;</code>，在这个组件上使<br>用 <code>v-bind:is</code> 指令来选择不同的组件。</p>
<p>例如一个组件的模板是这样的：</p>
<pre><code>&lt;button v-for=&quot;tab of tabs&quot;
        v-on:click=&quot;currentTab=tab&quot;/&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;</code></pre><p>那么当我们点击不同的导航栏标题的时候，<code>&lt;component&gt;</code> 组件就会根据 <code>currentTab</code><br>的不同，选择不同的组件。</p>
<h3 id="在动态组件上面使用-keep-alive-来使得组件得以缓存"><a href="#在动态组件上面使用-keep-alive-来使得组件得以缓存" class="headerlink" title="在动态组件上面使用 keep-alive 来使得组件得以缓存"></a><strong>在动态组件上面使用 <code>keep-alive</code> 来使得组件得以缓存</strong></h3><p>一般情况下，动态组件会随着组件的切换，重新渲染一个新的组件对象。也就是说，当<br>我们切换组件的时候，之前那个组件的内容在重新切回这个组件的时候会消失不见。为<br>了保持之前那个组件的状态，可以使用 <code>&lt;keep-alive&gt;</code> 元素将 <code>component</code> 包裹起来，这<br>样失活的组件将会被缓存起来。</p>
<p>具体的做法是：  </p>
<pre><code>&lt;keep-alive&gt;
    &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;
&lt;/keep-alive&gt;</code></pre><p>需要注意的是：这个需要保持活性的组件应该始终拥有自己的名字，无论是通过组件的<br><code>name</code> 选项，还是通过全局注册/局部注册。</p>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a><strong>异步组件</strong></h3><p>当想要异步从服务器中获取某一个组件的时候，我们可以使用<strong>异步组件</strong>的功能。Vue提供<br>的异步组件的使用方法是通过一个工厂函数来定义一个需要异步加载的组件，Vue 只有在<br>这个组件需要被加载的时候才会运行这个工厂函数，且 Vue 会将这个已经加载好了的组件<br>缓存起来供未来渲染。<br>像这样定义一个异步组件：  </p>
<pre><code>Vue.component(&apos;async-component&apos;,function(resolve, reject){
    // 这里使用 setTimeout 来模拟异步获取
    setTimeout(()=&gt;{
        // 假如 data 是获取到的数据或者模板
        if(data){
            resolve(data) // 这个是 promise 对象的使用，表示成功获取到数据
        }else{
            reject(reason) // 假如 reason 是失败的原因
        }
    })
})</code></pre><p>其中，当我们成功获取到数据的时候，Vue 会调用 <code>resolve</code> 回调函数，反之则调用 <code>reject</code><br>回调函数。</p>
<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a><strong>处理边界情况</strong></h2><h3 id="访问子组件或者子元素"><a href="#访问子组件或者子元素" class="headerlink" title="访问子组件或者子元素"></a><strong>访问子组件或者子元素</strong></h3><p>当我们想要在父级组件中访问子组件或者子元素对象的时候，可以在这个子组件或者子<br>元素中添加 ref 这个属性。这样我们就可以在父组件中通过 $refs 这个组件实例属性来获<br>取这个组件中所有带有 ref 这个属性的子组件对象。</p>
<p>需要<strong>注意</strong>的是：通过这种方式获取的子组件属性并不是响应式的，这仅仅是为了获取子<br>组件临时状态的一种方法, 不应该在模板或者计算属性中访问 <code>$refs</code></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p>当我们想要让一个组件的所有子组件都能够获取它的一个属性的话，我们可以使用<strong>依赖注入</strong>。<br>具体的做法是在这个组件中添加一个 <code>provide</code> 选项，选项中提供一个共享属性，例如：</p>
<pre><code>provide: function(){
    return {
        getMap: this.map
    }
}</code></pre><p>相应的，在这个组件的子组件中提供一个 <code>inject</code> 选项来注入这个属性，像这样：  </p>
<pre><code>inject:[&apos;getMap&apos;]</code></pre><p>那么，这个子组件就可以访问这个 <code>map</code> 属性，而不需要知道这个属性来自于哪个父级组件。<br>相应的，提供这个属性的父级组件也不知道那个子组件会使用它。</p>
<p>需要<strong>注意</strong>的是：这种做法并不是响应式的。也就是说，子组件获取到的这个属性即使更改了<br>父级组件的那个属性并不会随之更改。</p>
<h3 id="程序化事件侦听器"><a href="#程序化事件侦听器" class="headerlink" title="程序化事件侦听器"></a><strong>程序化事件侦听器</strong></h3><p>当想要在程序流程中自定义某一个组件的事件监听和取消监听，可以使用：  </p>
<ul>
<li><code>$on(event, eventHandler)</code> 监听一个事件</li>
<li><code>$once(event, eventHandler)</code> 一次性监听一个事件（只监听一次）</li>
<li><code>$off(event, eventHandler)</code> 取消监听一个事件</li>
</ul>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a><strong>循环引用</strong></h3><ol>
<li><p>递归组件</p>
<p> 组件是可以在模板中调用自己的，这样就形成了一个递归组件。但是需要注意设置递归<br> 的退出条件（例如最终会得到一个 <code>false</code> 的 <code>v-if</code> 组件），否则这个组件会无穷递归下<br> 去，Vue 会报一个 <code>max stack size exceed</code> 的错误。</p>
</li>
<li><p>组件之间的循环引用</p>
<p> 当我们想要在组件之间实现类似一种<em>组合模式</em>的时候，也就是像文件系统那样，一个文<br> 件可以是一个文件夹，也可以是一个文件，很容易出现这样一种组件的使用方式：  </p>
<pre><code>// &lt;folder&gt;组件的模板内容
template: `
    &lt;p&gt;
        &lt;span&gt;{{folder.name}}&lt;/span&gt;
        &lt;folder-contents v-bind:children=&quot;folder.children&quot;/&gt;  
    &lt;/p&gt;
`</code></pre><p> ##</p>
<pre><code>// &lt;folder-contents&gt; 组件的模板内容
template： `
    &lt;ul&gt;
        &lt;li v-for=&quot;child of children&quot;&gt;
            &lt;!--这里表示这个 child 是一个文件目录--&gt;
            &lt;folder v-if=&quot;child.children&quot; v-bind:folder=&quot;child&quot;/&gt;
            &lt;!--这里表示这个 child 是一个文件--&gt;
            &lt;span v-else&gt;{{child.name}}&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
`</code></pre><p> 看似这两个组件这么使用好像没什么问题，实际上，这里会出现一个逻辑上的矛盾：当 Vue<br> 想要渲染 <code>folder</code> 组件的时候，发现它的子组件是 <code>folder-contents</code> ，当想要渲染<br> <code>folder-contents</code> 组件的时候，却发现需要渲染它的父组件。当使用全局注册这两个组件<br> 的时候， Vue 会解决这个矛盾，但是当使用一个像 <em>webpack</em>  这样的模块系统的时候，组件<br> 之间的依赖是通过导入一个单文件形成的，这样就会出现循环依赖的错误。  </p>
<p> 解决方法是给模块系统设置一个依赖点，也就是当渲染一个组件的时候，人为的设置它所依赖<br> 的组件先不用渲染，只给一个定义，这样就退出了这个循环依赖。在这个例子中，<code>&lt;folder&gt;</code><br> 组件就是这个点，可以在组件的生命周期钩子 <code>beforeCreate</code> 中先给一个定义：  </p>
<pre><code>beforeCreate: () =&gt; require(&quot;./folder-component.vue&quot;).default  </code></pre><p> 或者使用 <em>webpack</em> 的异步导入方法 <code>import</code> ：  </p>
<pre><code>components: {
    &quot;folder-component&quot; : () =&gt; import(&quot;./folder-component.vue&quot;)
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yukino Li</p>
  <div class="site-description" itemprop="description">a blogging site to log my study and life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/yukino-blog/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/yukino-blog/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/yukino-blog/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BigtigerGG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BigtigerGG" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1602006646@qq.com" title="E-Mail → mailto:1602006646@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yukino Li</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/yukino-blog/lib/anime.min.js"></script>
  <script src="/yukino-blog/lib/velocity/velocity.min.js"></script>
  <script src="/yukino-blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/yukino-blog/js/utils.js"></script>

<script src="/yukino-blog/js/motion.js"></script>


<script src="/yukino-blog/js/schemes/pisces.js"></script>


<script src="/yukino-blog/js/next-boot.js"></script>




  




  
<script src="/yukino-blog/js/local-search.js"></script>













  

  

</body>
</html>
