<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/yukino-blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/yukino-blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/yukino-blog/images/favicon.png">
  <link rel="mask-icon" href="/yukino-blog/images/favicon.png" color="#222">

<link rel="stylesheet" href="/yukino-blog/css/main.css">


<link rel="stylesheet" href="/yukino-blog/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://bigtigergg.github.io/yukino-blog').hostname,
    root: '/yukino-blog/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="a blogging site to log my study and life">
<meta property="og:type" content="website">
<meta property="og:title" content="Yukino&#39;s Blog">
<meta property="og:url" content="https://bigtigergg.github.io/yukino-blog/index.html">
<meta property="og:site_name" content="Yukino&#39;s Blog">
<meta property="og:description" content="a blogging site to log my study and life">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yukino Li">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bigtigergg.github.io/yukino-blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Yukino's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/yukino-blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yukino's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">study and life</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/yukino-blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/yukino-blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/yukino-blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/yukino-blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/yukino-blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/yukino-blog/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/2020/01/20/:category/:title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/2020/01/20/:category/:title/" class="post-title-link" itemprop="url">动画和过渡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-20 23:31:25 / 修改时间：23:33:03" itemprop="dateCreated datePublished" datetime="2020-01-20T23:31:25+08:00">2020-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动画和过度"><a href="#动画和过度" class="headerlink" title="动画和过度"></a>动画和过度</h1><p>这篇文章记录了 Vue 对动画和过度效果的支持，同时记录了我的一些理解</p>
<h2 id="组件的过渡"><a href="#组件的过渡" class="headerlink" title="组件的过渡"></a><strong>组件的过渡</strong></h2><p>Vue 提供了 <code>transition</code> 内置组件用于下列情形的任意元素的过渡：</p>
<ul>
<li>条件渲染（<code>v-if</code>)</li>
<li>条件展示（<code>v-show</code>)</li>
<li>动态组件（被 <code>component</code> 包裹的组件）</li>
<li>组件根节点</li>
</ul>
<p>被 <code>transition</code> 组件包裹的组件在插入或者删除的时候，Vue 会做下述护理：  </p>
<ol>
<li><p>自动探测 <code>transition</code> 组件是否应用了 css过渡或者动画，如果是，则在恰当的时机<br>添加或者删除相应的 class 类</p>
</li>
<li><p>如果过渡组件提供了相应的 Javascript 钩子函数，这些钩子函数会在恰当的时机被调用  </p>
</li>
<li><p>如果没有上述两种情况，则 DOM 操作会在下一帧立即执行，也就是说没有过渡的效果</p>
</li>
</ol>
<p>使用 <code>transition</code> 组件的方法是给这个组件定义一个 name 属性，这个属性会作为下面六种 Vue<br>内置的 CSS 过渡类的类名前缀，在样式表中探测是否存在这种格式的类，并在适当的时机为包裹<br>元素添加相应的类名。这六种过渡类分别是：  </p>
<ol>
<li><code>v-enter</code> : 定义了<strong>进入</strong>过渡的开始状态，也就是这个组件被插入之前的 class 类，这个class<br>在元素被插入之后的下一帧移除。  </li>
<li><code>v-enter-active</code> ：定义了<strong>进入</strong>过渡生效时的状态，这个 class 类在整个过渡过程的时候生<br>效，在过渡 / 动画完成后移除。这个类通常被用来设置过渡的效果，例如过渡时间，过渡<br>曲线等，动画类似。</li>
<li><code>v-enter-to</code> : 定义了<strong>进入</strong>过渡的结束状态。在元素被插入的下一帧生效，在过渡 / 动画完成<br>时候移除。</li>
<li><code>v-leave</code> : 定义了<strong>离开</strong>过渡的开始状态，对应 <code>v-enter-to</code> 的状态，在离开过渡触发生效，<br>下一帧被移除。</li>
<li><code>v-leave-active</code> ：定义了<strong>离开</strong>过渡的生效状态，同 <code>v-enter-active</code>。</li>
<li><code>v-leave-to</code> : 定义了<strong>离开</strong>过渡的结束状态，同 <code>v-enter</code>。</li>
</ol>
<p>下图展示了这六种 class 类的在整个过渡过程的生效时间：  </p>
<p><img src="/images/transition.png" alt="transition"></p>
<p>需要注意的是，  </p>
<ol>
<li>这里的 v 前缀是当 <code>transition</code> 组件没有定义 <code>name</code> 属性的时候默认的。<br>当定义了 <code>name</code> 属性的时候，这个 v 会被替换为 <code>name</code> 所定义的内容。</li>
<li>css 动画的使用和过渡类似，唯一的区别是 <code>v-enter</code> 类名再节点被插入<br>时候不会被立即删除，而是在 <code>animationend</code> 事件触发的时候被删除。</li>
</ol>
<h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a><strong>自定义过渡的类名</strong></h3><p>当想要使用第三方 css 类库的时候，我们可以定义 <code>transition</code> 组件的内联样式属性：  </p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code></li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code></li>
</ul>
<p>这六个作为 <code>transition</code> 组件的属性具有最高优先级，可以和 Vue 的过渡系统结合起来。</p>
<h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a><strong>同时使用过渡和动画</strong></h3><p>当想要给过渡或者动画添加事件监听机制的时候，需要给 <code>transition</code> 组件添加相应的事<br>件监听器，过渡—— <code>transitionend</code>, 动画—— <code>animationend</code>。Vue 会根据具体的 CSS<br>识别并添加监听器。  </p>
<p>当同时使用这两种效果的时候。 需要在 <code>transition</code> 组件明确指定 <code>type</code> 这个属性并设置<br><code>transition</code> 或者 <code>animation</code> 来区分这两种动效。</p>
<h3 id="多个元素（组件）的过渡"><a href="#多个元素（组件）的过渡" class="headerlink" title="多个元素（组件）的过渡"></a><strong>多个元素（组件）的过渡</strong></h3><p>当一个 <code>transition</code> 组件包含多个元素（组件）的时候，且这些元素（组件）在同一时间<br>只渲染一个的时候，可以在 <code>transition</code> 组件中使用 <code>v-if</code>, <code>v-else</code>, 控制元素的渲染，用<br>动态组件控制组件的渲染。  </p>
<p>需要注意的是这些元素（组件）的切换的时候，它们的渲染模式在默认情况下是进入状态<br>和离开状态同时发生。这在某些情况下可能达不到预期的效果， Vue 提供了过渡模式，让<br>两个组件的渲染过渡拥有先后次序：  </p>
<ul>
<li><code>in-out</code> : 新元素先进行过渡，过渡完成后当前元素过渡离开</li>
<li><code>out-in</code> : 当前元素先进行过渡，过渡完成后新元素过渡进入  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/2020/01/20/:category/:title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/2020/01/20/:category/:title/" class="post-title-link" itemprop="url">Vue 指令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-20 23:30:25 / 修改时间：23:31:55" itemprop="dateCreated datePublished" datetime="2020-01-20T23:30:25+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h1><p><strong>每学习一个指令，将其用法和自己的理解记录下来</strong></p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><strong>v-bind</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p><code>v-bind</code> 指令是一个用于将 vue 实例中的数据属性或者prop动态地和 html 标签中的属性绑定<br>起来。当 vue 实例中的数据属性发生改变时，html 标签中的属性也会响应式的变化。  </p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><ul>
<li><p>缩写： <code>:</code></p>
</li>
<li><p>参数： <code>attr | prop</code></p>
</li>
<li><p>修饰符：  </p>
<ul>
<li><code>.prop</code> 待续</li>
<li><code>.camel</code> 待续</li>
<li><code>.sync</code> 待续</li>
</ul>
</li>
<li><p>说明：<br>  动态的绑定一个或多个属性，或用一个prop到表达式。  </p>
<p>  在绑定 <code>style</code> 或 <code>class</code> 特性时，支持其它类型的值，如数组或者对象。 </p>
<p>  在绑定prop时，prop必须在子组件中声明。可以用修饰符指定不同的绑定类型。  </p>
<p>  没有参数时，可以绑定一个包含键值对的对象。**注意，此时 <code>class</code> 和 <code>style</code> 绑定不支持数组或者对象。  </p>
<p>  <em>下面是我自己的理解：</em>  </p>
<ul>
<li>动态绑定一个属性的时候，将null值作为参数，将会取消这个绑定事件。</li>
</ul>
</li>
<li><p>示例  </p>
<pre><code>&lt;!-- 绑定一个属性 --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot;&gt;

&lt;!-- 动态特性名 (2.6.0+) --&gt;
&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;

&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;
&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;

&lt;!-- 内联字符串拼接 --&gt;
&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;

&lt;!-- class 绑定 --&gt;
&lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;

&lt;!-- style 绑定 --&gt;
&lt;div :style=&quot;{ fontSize: size + &apos;px&apos; }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;

&lt;!-- 绑定一个有属性的对象 --&gt;
&lt;div v-bind=&quot;{ id: someProp, &apos;other-attr&apos;: otherProp }&quot;&gt;&lt;/div&gt;

&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;
&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;

&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;
&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;

&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;
&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;

&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</code></pre></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/2020/01/20/:category/:title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/2020/01/20/:category/:title/" class="post-title-link" itemprop="url">Vue 实例</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-20 23:21:25 / 修改时间：23:31:04" itemprop="dateCreated datePublished" datetime="2020-01-20T23:21:25+08:00">2020-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h1><h2 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h2><p>每一个 Vue 应用都是通过 <code>Vue</code> 函数创建一个新的 Vue 实例开始的  </p>
<pre><code>var vm = new Vue({
    // 选项
});  </code></pre><p>当创建一个 Vue 实例时，可以传入一个选项对象。<br>每一个 Vue 应用通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的，嵌套的、可复用的<em>组件</em> 树<br>组成。</p>
<h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据作为一个 Vue 实例的属性，当这个属性被改变时，视图将会产生响应(也就是同步的改变)，因为这个属性被加入到了 Vue 的响应式系统中了。</p>
<p>为一个 Vue 实例添加数据的方式如下:  </p>
<pre><code>var vm = new Vue({
    data: {
        msg: &quot;hello vue!&quot;
    }
});</code></pre><p>这样就为 vm 这个 Vue 实例添加了一个属性名为 msg 的数据，他的值为 “hello vue” 。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法作为一个 vue 实例的方法，通过在 vue 实例中定义它们，就可以在一些需要动态改变数据的地方用<br>到这些方法</p>
<p>为一个 Vue 实例添加方法的方式如下：</p>
<pre><code>var vm = new Vue({
    data: {
        msg: &quot;hello vue&quot;
    },
    methods: {
        reverseMsg: function(){
            this.msg = this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;);
        }
    }
});</code></pre><p>这里为 vm 这个 vue 实例添加了一个 <code>reverseMsg</code> 的方法,  这个方法将实例中的msg属性这个字符串反<br>转了</p>
<blockquote>
<p><strong><font color='red' size='4'>注意</font></strong><br>不要在选项属性或回调上使用箭头函数，比如 <code>created: () =&gt; console.log(this.a)</code><br>或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<br><code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught   
TypeError: Cannot read property of undefined</code>或 <code>Uncaught TypeError:  
this.myMethod is not a function</code> 之类的错误。</p>
</blockquote>
<h2 id="Vue-实例的生命周期"><a href="#Vue-实例的生命周期" class="headerlink" title="Vue  实例的生命周期"></a>Vue  实例的生命周期</h2><p><img src="/images/vue-instance-lifecycle.png" alt="Vue实例生命周期示意图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bigtigergg.github.io/yukino-blog/2020/01/20/:category/:title/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/yukino-blog/images/avatar.gif">
      <meta itemprop="name" content="Yukino Li">
      <meta itemprop="description" content="a blogging site to log my study and life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yukino's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/yukino-blog/2020/01/20/:category/:title/" class="post-title-link" itemprop="url">深入了解 Vue 组件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-20 22:57:25 / 修改时间：23:28:43" itemprop="dateCreated datePublished" datetime="2020-01-20T22:57:25+08:00">2020-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/yukino-blog/categories/Vue/Vue-Base/" itemprop="url" rel="index">
                    <span itemprop="name">Vue Base</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a><strong>深入了解组件</strong></h1><p>这篇文章记录组件的高级知识，和自己对组件的总结。</p>
<h2 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a><strong>组件的注册</strong></h2><p>&emsp;&emsp;组件的注册包括全局注册和局部注册两种。</p>
<ul>
<li><p>全局注册  </p>
<p>  即通过 <code>Vue.component({/\*\*...\*\*/})</code> 来注册组件。<br>  全局注册的组件可用于任何新创建的 Vue 实例，也包括组件之间相互的使用。</p>
</li>
<li><p>局部注册  </p>
<p>  全局注册的组件，即便不想使用这个组件，它任然会包含在构建结果中。这造成了<br>  用户下载的 JavaScript 的无谓的增加。<br>  通过使用局部组件，可以避免这个问题。局部注册的方法如下：  </p>
<pre><code>// 通过使用变量，将组件的引用赋值给一个变量
var ComponentA = { /\* ... \*/ }
var ComponentB = { /\* ... \*/ }
// 然后在一个 Vue 实例中的 components 定义你想使用的组件
new Vue({
    el: &quot;#app&quot;,
    components: {
        &apos;component-a&apos; : ComponentA,
        &apos;component-b&apos; : ComponentB
    }
})</code></pre><p>  需要<strong>注意</strong>的是：  </p>
<ul>
<li>对于 <code>components</code> 对象中的每一个属性来说，其属性名就是自定<br>义元素的名字，其属性值就是某一个组件的变量名。</li>
<li>局部注册的组件在其子组件中不可用。如果想要在子组件中使用，<br>需要在子组件中注册这个组件。 </li>
</ul>
</li>
</ul>
<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a><strong>Prop</strong></h2><h3 id="prop-的类型"><a href="#prop-的类型" class="headerlink" title="prop 的类型"></a><strong>prop 的类型</strong></h3><p>通常prop的传递通过字符串数组的形式，比如这样：  </p>
<pre><code>props:[&apos;prop1&apos;, &apos;prop2&apos;, &apos;prop3&apos;]</code></pre><p>但是，通常我们希望每一个 <code>prop</code> 都有自己指定值的类型。这时，我们可以用对象的形式<br>列出 <code>prop</code>，这些属性的名称和值分别是prop各自的名称和类型。这样也可以对 prop。<br>进行类型检查。例如：  </p>
<pre><code>props: {
    title: String,
    likes: Number,
    isPublished: Boolean
}</code></pre><h3 id="prop-的传递应该是一个单向数据流"><a href="#prop-的传递应该是一个单向数据流" class="headerlink" title="prop 的传递应该是一个单向数据流"></a><strong>prop 的传递应该是一个单向数据流</strong></h3><p>所有的prop都使得其父子prop之间形成了一个<strong>单向下行绑定</strong>：父级prop的更新会向下流动<br>到子组件中，但是反过来却不行。这样能够防止从子组件意外改变父级组件的状态，从而<br>导致应用的数据流向难以理解。</p>
<p>每次父级组件发生更新的时候，子组件中的所有prop都会刷新为最新的值。这意味着不应该<br>在一个子组件内部改变 prop。 </p>
<h3 id="非-prop-的-Attribute"><a href="#非-prop-的-Attribute" class="headerlink" title="非 prop 的 Attribute"></a><strong>非 prop 的 Attribute</strong></h3><p>一个非 prop 的 Attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的Attribute。<br>但是一个组件可以接受任意的 attribute ，<strong>而这个attribute会被添加到这个组件的根元素上</strong>。 </p>
<h3 id="替换-合并已有的-attribute"><a href="#替换-合并已有的-attribute" class="headerlink" title="替换/合并已有的 attribute"></a><strong>替换/合并已有的 attribute</strong></h3><p>对于绝大数的 attribute，外部提供给组件的值会替换掉组件内部根元素设定好了的值。但是<br>style 和 class 属性会合并两个值。</p>
<h3 id="禁用-attribute-继承"><a href="#禁用-attribute-继承" class="headerlink" title="禁用 attribute 继承"></a><strong>禁用 attribute 继承</strong></h3><p>当不希望一个组件内部的根元素(组件)继承外部的属性，那么可以将这个组件的 <code>inheritAttrs</code><br>属性设置为 <code>false</code>。例如：</p>
<pre><code>Vue.component(&apos;demo-component&apos;, {
    inheritAttrs: false,
    template: /* ... */
})</code></pre><p>这样书写给 <code>demo-component</code> 这个组件的属性就不会继承到它的子组件中。</p>
<p>值得注意的是，这样做的好处在于：<br>当一个组件的模板嵌套着很多子组件时，我们不希望配置给这个组件的属性直接继承在这个组件<br>的根组件上，而是继承给某一个我们希望的子组件上面。 </p>
<p>具体的做法是：  </p>
<ol>
<li>禁用属性继承（即 <code>inheritAttrs: false</code>）</li>
<li>将组件的实例属性 <a href="https://cn.vuejs.org/v2/api/#vm-attrs" target="_blank" rel="noopener"><code>$attrs</code></a> , 绑定到指定的子组件或者元素上面  </li>
</ol>
<p>需要<strong>注意</strong>的是：  </p>
<p><code>inheritAttrs: false</code> 并<strong>不会</strong>影响到 style 和 class 的绑定。也就是说，这两个属性<br>还是会绑定在模板的根元素（子组件）上面。</p>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a><strong>自定义事件</strong></h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a><strong>事件名</strong></h3><p>不同于组件和prop，事件名不会存在任何的自动化的大小写转换，而是触发的事件名必须<br>完全匹配这个事件所用的名称。  </p>
<p>建议始终使用短横线分割的小写标识符。</p>
<h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a><strong>自定义组件的 <code>v-model</code></strong></h3><p><code>v-model</code> 用在组件上面的时候，会默认利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，<br>当使用一些像单选框，复选框这样的输入表单控件的时候，这个指令就达不到我们想要<br>的效果。这个时候，我们可以使用 Vue 实例中的 <code>model</code> 选项用来避免这样的冲突。<br>例如：  </p>
<pre><code>Vue.component(&apos;base-checkbox&apos;, {
    model: {
        prop: &apos;checked&apos;,
        event: &apos;change&apos;
    },
    props: {
        checked: Boolean
    },
    template: `
        &lt;input type=&quot;checkbox&quot;
               :checked=&quot;checked&quot;
               @change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot;
        &gt;
    `
})</code></pre><p>这样当在 <code>base-checkbox</code> 这个组件上使用 <code>v-model</code> 的时候，将会创建一个和checked<br>双向绑定的响应式关系。</p>
<h3 id="使用-listeners-属性将原生事件绑定到组件中"><a href="#使用-listeners-属性将原生事件绑定到组件中" class="headerlink" title="使用 $listeners 属性将原生事件绑定到组件中"></a><strong>使用 $listeners 属性将原生事件绑定到组件中</strong></h3><p>绑定原生 DOM 事件的方法是在 <code>v-on</code> 这个指令上面加上 <code>.native</code> 这个修饰符。<br>但是，当在一个组件上绑定一个原生事件并且组件内部尝试监听一个特定的元<br>素的时候，父级的 .native 监听器将会失败。Vue 不会报错，但是相应的事件处<br>理函数将不会执行。  </p>
<p>这个时候，可以使用 Vue 提供的 $listeners 属性将组件上所有的事件监听器指<br>向这个组件上的指定元素。具体的方法是：</p>
<pre><code>// 例如我们想要将一个组件上面的 focus 事件监听器指向这个组件内部的一个 input 元素
Vue.component(&apos;base-input&apos;, {
    inheritAttrs: false,
    props: [&apos;input&apos;]
    computed: {
        inputListeners: function(){
            let vm = this;
            // 使用 Object.assign 方法将多个对象合并
            return Object.assign({}, 
                this.$listeners,
                {
                    input: function(){
                        vm.$emit(&apos;input&apos;, $event.target.value);
                    }
                }
            )
        }
    },
    template: `
        &lt;label&gt;
            &lt;input type=&quot;text&quot;
                   v-bind=&quot;$attrs&quot;
                   :input=&quot;input&quot;
                   v-on=&quot;inputListeners&quot;&gt;
        &lt;/label&gt;
    `
})</code></pre><p>这样使用 <code>base-input</code> 就相当于使用普通的 <code>input</code> 了，也就是说，这个组件<br>已经是透明的了。</p>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a><strong>插槽</strong></h2><h3 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a><strong>插槽的基本使用</strong></h3><p>当我们想要在一个组件中插入一段模板或者HTML的时候，可以使用 Vue 提供<br>的插槽机制。如果不使用插槽，并且在一个自定义组件中插入了一段模板或者<br>HTML的话，那么 Vue 将不会渲染这一部分的内容。</p>
<p>插槽的具体使用方式如下：</p>
<pre><code>// 假如这是一个名为 &lt;my-slot&gt; 组件的模板内容
&lt;label&gt;
    &lt;span&gt;你好&lt;/span&gt;
    &lt;slot&gt;&lt;/slot&gt;
&lt;/label&gt;</code></pre><p>###<br>可以像使用 html 元素一样使用这个组件</p>
<pre><code>&lt;my-slot&gt;
    Vue
&lt;/my-slot&gt;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>经过 Vue 渲染后的结果为：</p>
<pre><code>你好Vue</code></pre><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a><strong>具名插槽</strong></h3><p>当想要使用多个插槽的时候，可以在 <code>&lt;slot&gt;</code> 元素上面添加一个 <code>name</code> 特性，这个<br>特性可以作为识别这个插槽的标识。然后在具体使用这个模板的时候，使用 <code>v-slot</code><br>指令，将 name 作为这个指令的参数，作用在一个模板组件 <code>&lt;template&gt;</code> 上面。那<br>么这个模板的内容将被填充在这个插槽里面。未使用 name 特性的 <code>&lt;slot&gt;</code> 将会有<br>一个默认的 name —— default。未使用 <code>&lt;template&gt;</code> 的内容将会视作默认插槽的内<br>容。使用这种方式定义的插槽叫做<strong>具名插槽</strong>。</p>
<p><strong>注：</strong><br>和其他可缩写指令一样，<code>v-slot</code> 指令可以缩写为 <code>#</code>, 但必须指定参数，也就是<br>说不能这样用：<code>#=</code></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a><strong>作用域插槽</strong></h3><p>当想在父级组件作用域中使用子组件中作用域中的数据的时候，可以使用 Vue 提供的<br>作用域插槽的解决方案。<br>具体的使用方法如下：</p>
<pre><code>// 假如在父级组件或者 rawHtml 中需要使用一个叫做 isCompleted 的属性
// 这是子组件
var todoList = {
    props:{
        todoItems: Array
    },
    computed: {
        filteredTodoItems: function(){
            return this.todoItems.filter(item =&gt; item.title);
        }
    },
    // 绑定在&lt;slot&gt;标签中的特性被称为插槽 prop , 这个prop在父级作用域中
    // 可以通过 v-slot 指令提供的插槽 prop 名字来访问
    template: `
        &lt;ul&gt;
            &lt;li v-for=&quot;item of filteredTodoItems
                :key=&quot;item.id&quot;&gt;
                &lt;slot v-bind:todo=&quot;item&quot;&gt;
                    {{item.title}}
                &lt;/slot&gt;
                &lt;input type=&quot;checkbox&quot; v-model=&quot;item.isCompleted&quot;&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    `
};

new Vue({
    el:&quot;#component-slot-prop&quot;,
    data: {
        todoItems: [
            {
                id: 0,
                title: &quot;学习 Vue 的插槽用法&quot;,
                isCompleted: false
            },
            {},
            {
                id: 3,
                title: &quot;学习 JVM 的知识&quot;,
                isCompleted: false
            }
        ]
    },
    components: {
        &quot;todo-list&quot;: todoList
    }
});

// 在父级组件中访问这个插槽 prop，根据 isCompleted 的值来条件渲染
&lt;div id=&quot;component-slot-prop&quot;&gt;
&lt;!-- 这里使用解构对象给 v-slot 指令赋值 --&gt;
    &lt;todo-list v-slot=&quot;{ todo }&quot;
               :todo-items=&quot;todoItems&quot;&gt;
        &lt;span v-if=&quot;todo.isCompleted&quot;&gt; ✔ &lt;/span&gt;
        {{todo.title}}
    &lt;/todo-list&gt;
&lt;/div&gt;</code></pre><p><strong>注：</strong><br>作用域插槽的更多用法 ==&gt; <a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener" title="一个基于 Vue 的虚拟滑动器，旨在提高性能">Vue Virtural Scroller</a></p>
<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a><strong>动态组件 &amp; 异步组件</strong></h2><p>当我们想要根据条件，动态渲染某一个组件的时候，可以使用 Vue 提供的<br>动态组件功能。例如，当我们选择一个导航栏标题的时候，内容区域根据标<br>题的不同使用不同的组件。</p>
<p>具体的做法是使用一个 Vue 提供的内置组件 <code>&lt;component&gt;</code>，在这个组件上使<br>用 <code>v-bind:is</code> 指令来选择不同的组件。</p>
<p>例如一个组件的模板是这样的：</p>
<pre><code>&lt;button v-for=&quot;tab of tabs&quot;
        v-on:click=&quot;currentTab=tab&quot;/&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;</code></pre><p>那么当我们点击不同的导航栏标题的时候，<code>&lt;component&gt;</code> 组件就会根据 <code>currentTab</code><br>的不同，选择不同的组件。</p>
<h3 id="在动态组件上面使用-keep-alive-来使得组件得以缓存"><a href="#在动态组件上面使用-keep-alive-来使得组件得以缓存" class="headerlink" title="在动态组件上面使用 keep-alive 来使得组件得以缓存"></a><strong>在动态组件上面使用 <code>keep-alive</code> 来使得组件得以缓存</strong></h3><p>一般情况下，动态组件会随着组件的切换，重新渲染一个新的组件对象。也就是说，当<br>我们切换组件的时候，之前那个组件的内容在重新切回这个组件的时候会消失不见。为<br>了保持之前那个组件的状态，可以使用 <code>&lt;keep-alive&gt;</code> 元素将 <code>component</code> 包裹起来，这<br>样失活的组件将会被缓存起来。</p>
<p>具体的做法是：  </p>
<pre><code>&lt;keep-alive&gt;
    &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;
&lt;/keep-alive&gt;</code></pre><p>需要注意的是：这个需要保持活性的组件应该始终拥有自己的名字，无论是通过组件的<br><code>name</code> 选项，还是通过全局注册/局部注册。</p>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a><strong>异步组件</strong></h3><p>当想要异步从服务器中获取某一个组件的时候，我们可以使用<strong>异步组件</strong>的功能。Vue提供<br>的异步组件的使用方法是通过一个工厂函数来定义一个需要异步加载的组件，Vue 只有在<br>这个组件需要被加载的时候才会运行这个工厂函数，且 Vue 会将这个已经加载好了的组件<br>缓存起来供未来渲染。<br>像这样定义一个异步组件：  </p>
<pre><code>Vue.component(&apos;async-component&apos;,function(resolve, reject){
    // 这里使用 setTimeout 来模拟异步获取
    setTimeout(()=&gt;{
        // 假如 data 是获取到的数据或者模板
        if(data){
            resolve(data) // 这个是 promise 对象的使用，表示成功获取到数据
        }else{
            reject(reason) // 假如 reason 是失败的原因
        }
    })
})</code></pre><p>其中，当我们成功获取到数据的时候，Vue 会调用 <code>resolve</code> 回调函数，反之则调用 <code>reject</code><br>回调函数。</p>
<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a><strong>处理边界情况</strong></h2><h3 id="访问子组件或者子元素"><a href="#访问子组件或者子元素" class="headerlink" title="访问子组件或者子元素"></a><strong>访问子组件或者子元素</strong></h3><p>当我们想要在父级组件中访问子组件或者子元素对象的时候，可以在这个子组件或者子<br>元素中添加 ref 这个属性。这样我们就可以在父组件中通过 $refs 这个组件实例属性来获<br>取这个组件中所有带有 ref 这个属性的子组件对象。</p>
<p>需要<strong>注意</strong>的是：通过这种方式获取的子组件属性并不是响应式的，这仅仅是为了获取子<br>组件临时状态的一种方法, 不应该在模板或者计算属性中访问 <code>$refs</code></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p>当我们想要让一个组件的所有子组件都能够获取它的一个属性的话，我们可以使用<strong>依赖注入</strong>。<br>具体的做法是在这个组件中添加一个 <code>provide</code> 选项，选项中提供一个共享属性，例如：</p>
<pre><code>provide: function(){
    return {
        getMap: this.map
    }
}</code></pre><p>相应的，在这个组件的子组件中提供一个 <code>inject</code> 选项来注入这个属性，像这样：  </p>
<pre><code>inject:[&apos;getMap&apos;]</code></pre><p>那么，这个子组件就可以访问这个 <code>map</code> 属性，而不需要知道这个属性来自于哪个父级组件。<br>相应的，提供这个属性的父级组件也不知道那个子组件会使用它。</p>
<p>需要<strong>注意</strong>的是：这种做法并不是响应式的。也就是说，子组件获取到的这个属性即使更改了<br>父级组件的那个属性并不会随之更改。</p>
<h3 id="程序化事件侦听器"><a href="#程序化事件侦听器" class="headerlink" title="程序化事件侦听器"></a><strong>程序化事件侦听器</strong></h3><p>当想要在程序流程中自定义某一个组件的事件监听和取消监听，可以使用：  </p>
<ul>
<li><code>$on(event, eventHandler)</code> 监听一个事件</li>
<li><code>$once(event, eventHandler)</code> 一次性监听一个事件（只监听一次）</li>
<li><code>$off(event, eventHandler)</code> 取消监听一个事件</li>
</ul>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a><strong>循环引用</strong></h3><ol>
<li><p>递归组件</p>
<p> 组件是可以在模板中调用自己的，这样就形成了一个递归组件。但是需要注意设置递归<br> 的退出条件（例如最终会得到一个 <code>false</code> 的 <code>v-if</code> 组件），否则这个组件会无穷递归下<br> 去，Vue 会报一个 <code>max stack size exceed</code> 的错误。</p>
</li>
<li><p>组件之间的循环引用</p>
<p> 当我们想要在组件之间实现类似一种<em>组合模式</em>的时候，也就是像文件系统那样，一个文<br> 件可以是一个文件夹，也可以是一个文件，很容易出现这样一种组件的使用方式：  </p>
<pre><code>// &lt;folder&gt;组件的模板内容
template: `
    &lt;p&gt;
        &lt;span&gt;{{folder.name}}&lt;/span&gt;
        &lt;folder-contents v-bind:children=&quot;folder.children&quot;/&gt;  
    &lt;/p&gt;
`</code></pre><p> ##</p>
<pre><code>// &lt;folder-contents&gt; 组件的模板内容
template： `
    &lt;ul&gt;
        &lt;li v-for=&quot;child of children&quot;&gt;
            &lt;!--这里表示这个 child 是一个文件目录--&gt;
            &lt;folder v-if=&quot;child.children&quot; v-bind:folder=&quot;child&quot;/&gt;
            &lt;!--这里表示这个 child 是一个文件--&gt;
            &lt;span v-else&gt;{{child.name}}&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
`</code></pre><p> 看似这两个组件这么使用好像没什么问题，实际上，这里会出现一个逻辑上的矛盾：当 Vue<br> 想要渲染 <code>folder</code> 组件的时候，发现它的子组件是 <code>folder-contents</code> ，当想要渲染<br> <code>folder-contents</code> 组件的时候，却发现需要渲染它的父组件。当使用全局注册这两个组件<br> 的时候， Vue 会解决这个矛盾，但是当使用一个像 <em>webpack</em>  这样的模块系统的时候，组件<br> 之间的依赖是通过导入一个单文件形成的，这样就会出现循环依赖的错误。  </p>
<p> 解决方法是给模块系统设置一个依赖点，也就是当渲染一个组件的时候，人为的设置它所依赖<br> 的组件先不用渲染，只给一个定义，这样就退出了这个循环依赖。在这个例子中，<code>&lt;folder&gt;</code><br> 组件就是这个点，可以在组件的生命周期钩子 <code>beforeCreate</code> 中先给一个定义：  </p>
<pre><code>beforeCreate: () =&gt; require(&quot;./folder-component.vue&quot;).default  </code></pre><p> 或者使用 <em>webpack</em> 的异步导入方法 <code>import</code> ：  </p>
<pre><code>components: {
    &quot;folder-component&quot; : () =&gt; import(&quot;./folder-component.vue&quot;)
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yukino Li</p>
  <div class="site-description" itemprop="description">a blogging site to log my study and life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/yukino-blog/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BigtigerGG" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BigtigerGG" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1602006646@qq.com" title="E-Mail → mailto:1602006646@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yukino Li</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/yukino-blog/lib/anime.min.js"></script>
  <script src="/yukino-blog/lib/velocity/velocity.min.js"></script>
  <script src="/yukino-blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/yukino-blog/js/utils.js"></script>

<script src="/yukino-blog/js/motion.js"></script>


<script src="/yukino-blog/js/schemes/muse.js"></script>


<script src="/yukino-blog/js/next-boot.js"></script>




  




  
<script src="/yukino-blog/js/local-search.js"></script>













  

  

</body>
</html>
